{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u9a74\u8f66\u624b\u518c\u9996\u9875","title":"\u9996\u9875"},{"location":"#_1","text":"","title":"\u9a74\u8f66\u624b\u518c\u9996\u9875"},{"location":"aboutus/","text":"\u5173\u4e8e\u6211\u4eec \u6280\u672f\u9884\u7814\u53ca\u6587\u6863\u7ef4\u62a4\u56e2\u961f\u4eba\u5458\u540d\u5355 \u6392\u540d\u4e0d\u5206\u5148\u540e. \u8d75\u660e\u6770 Alex Zhao \u9648\u660a Henry Chen \u674e\u4f1f\u658c \u6f02\u79fb\u83cc \u987e\u521a \u6492\u54c8\u62c9\u5927\u91ce\u725b \u6b27\u9633\u519b Light","title":"\u5173\u4e8e\u6211\u4eec"},{"location":"aboutus/#_1","text":"","title":"\u5173\u4e8e\u6211\u4eec"},{"location":"aboutus/#_2","text":"\u6392\u540d\u4e0d\u5206\u5148\u540e. \u8d75\u660e\u6770 Alex Zhao \u9648\u660a Henry Chen \u674e\u4f1f\u658c \u6f02\u79fb\u83cc \u987e\u521a \u6492\u54c8\u62c9\u5927\u91ce\u725b \u6b27\u9633\u519b Light","title":"\u6280\u672f\u9884\u7814\u53ca\u6587\u6863\u7ef4\u62a4\u56e2\u961f\u4eba\u5458\u540d\u5355"},{"location":"donkeygym/gym_simulator/","text":"\u9a74\u8f66\u6a21\u62df\u5668 Donkey Gym\u9879\u76ee\u662f\u56f4\u7ed5\u81ea\u9a7e\u6c99\u76d2\u9a74\u6a21\u62df\u5668 ( )\u7684OpenAI. \u4ece\u6e90\u4ee3\u7801\u6784\u5efa\u6a21\u62df\u5668\u65f6\uff0c\u9700\u8981\u68c0\u67e5\u9879\u76ee\u7684donkey\u5206\u652f\u7684sdsandbox\u3002 \u8be5\u6a21\u62df\u5668\u5efa\u7acb\u5728Unity\u6e38\u620f\u5e73\u53f0\u4e0a\uff0c\u4f7f\u7528\u5176\u5185\u90e8\u7269\u7406\u548c\u56fe\u5f62\uff0c\u5e76\u8fde\u63a5\u5230\u9a74\u8f66Python\u8fdb\u7a0b\uff0c\u4ee5\u4f7f\u7528\u6211\u4eec\u8bad\u7ec3\u7684\u6a21\u578b\u6765\u63a7\u5236\u6a21\u62df\u7684\u9a74\u8f66. \u751a\u81f3\u901a\u8fc7\u811a\u672c\u4e2d\u7684 multitrain.py \u521b\u5efa\u591a\u4e2a AI \u5c0f\u8f66\u8fdb\u884c\u591a\u8f66\u540c\u65f6\u8dd1\u6a21\u62df\u5668\u73af\u5883\u8fdb\u884c\u8bad\u7ec3. \u5177\u4f53\u53c2\u89c1/donkeycar/donkeycar/scripts/multitrain.py \u6a21\u62df\u5668\u5b89\u88c5\u914d\u7f6e Windows\u7cfb\u7edf \u5b89\u88c5\u73af\u5883\u4f9d\u8d56 \u6ce8\u610f: \u5df2\u5728Windows 10\u4e0a\u6d4b\u8bd5\u8fc7. TBD Linux \u7cfb\u7edf \u5b89\u88c5\u73af\u5883\u4f9d\u8d56 \u6ce8\u610f: \u5df2\u5728Ubuntu 20.04 LTS\u4e0a\u6d4b\u8bd5\u8fc7. \u6253\u5f00\u4e00\u4e2a\u7ec8\u7aef(\u5feb\u6377\u952e Ctrl+ Alt + T) \u4e0b\u8f7d\u5e76\u5b89\u88c5miniconda python3.7 64bit\u7248\u672c miniconda Python 3.7 64 bit . wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh bash ./Miniconda3-latest-Linux-x86_64.sh \u521b\u5efa\u9879\u76ee\u76ee\u5f55\u5e76\u8fdb\u5165\u76ee\u5f55 mkdir projects cd projects \u4ece Github \u4e0a\u4e0b\u8f7d\u6700\u65b0\u7684donkeycar \u4ed3\u5e93. git clone https://github.com/autorope/donkeycar cd donkeycar git checkout main \u83b7\u53d6\u7a33\u5b9a\u7248\u672c git clone https://github.com/autorope/donkeycar cd donkeycar git fetch --all --tags latestTag=$(git describe --tags `git rev-list --tags --max-count=1`) git checkout $latestTag \u5982\u679c\u4e0d\u662f\u7b2c\u4e00\u6b21\u5b89\u88c5donkeycar,\u9700\u8981\u66f4\u65b0Conda\u73af\u5883\u548c\u79fb\u9664\u65e7\u7684donkey\u5e93. conda update -n base -c defaults conda conda env remove -n donkey \u521b\u5efa Python anaconda \u7684\u73af\u5883 conda env create -f install/envs/ubuntu.yml conda activate donkey pip install -e .[pc] \u6211\u4eec\u89c2\u5bdf\u5230 conda \u8fdb\u884c\u5b89\u88c5\u7684\u65f6\u5019\u975e\u5e38\u6162, \u4e24\u79cd\u65b9\u6cd5,\u4e00\u79cd\u662f\u6362 mamba ,\u4e00\u79cd\u5c31\u6362 Conda\u6e90. conda install mamba -n base -c conda-forge mamba env create -f install/envs/ubuntu.yml conda activate donkey pip install -e .[pc] \u6ce8\u610f: \u5982\u679c\u4f60\u662f\u7528 ZSH \u7684 shell, \u9700\u8981\u8f6c\u4e49\u4e00\u4e0b[pc],\u56e0\u6b64\u4f60\u9700\u8981\u8f93\u5165\u7684\u4e0d\u662f pip install -e . [pc] \u800c\u662f pip install -e . \\[pc\\] [\u53ef\u9009]\u5b89\u88c5 Tensorflow GPU - \u4ec5\u5f53\u4f60\u62e5\u6709 NVidia \u56fe\u5f62\u52a0\u901f\u5361\u7684\u65f6\u5019. \u4f60\u9700\u8981\u5148\u5b89\u88c5NVidia GPU\u7684\u6700\u65b0\u9a71\u52a8,\u5177\u4f53\u53c2\u8003\u4f60\u663e\u5361\u7684\u7c7b\u578b\u53bb\u82f1\u4f1f\u8fbe\u5b98\u65b9\u7ad9\u70b9\u5bfb\u627e. Conda \u4f1a\u5904\u7406\u5e76\u5b89\u88c5\u6b63\u786e\u7684 cuda \u548c cuddn \u7684\u5e93\u6765\u5339\u914d\u4f60\u7684 Tensorflow \u7248\u672c. conda install tensorflow-gpu==2.2.0 \u521b\u5efa\u4f60\u672c\u5730\u7684\u5de5\u4f5c\u76ee\u5f55: cd projects/donkeycar donkey createcar --path ../mycar \u6ce8\u610f:\u5982\u679c\u5173\u95ed\u4e86 Anaconda \u63d0\u793a\u7b26\u540e,\u91cd\u65b0\u6253\u5f00\u5c31\u9700\u8981\u8f93\u5165: \u8f93\u5165 conda activate donkey \u53bb\u91cd\u65b0\u6620\u5c04\u5230 donkey \u7684\u865a\u62df\u73af\u5883\u4e2d. MacOS \u7cfb\u7edf \u5df2\u7ecf\u5728 macOS Big Sur 11.6.5 \u73af\u5883\u4e0b\u6d4b\u8bd5\u901a\u8fc7. \u5b89\u88c5\u73af\u5883\u4f9d\u8d56 \u5b89\u88c5 miniconda Python 3.7 64bit \u7248\u672c miniconda Python 3.7 64 bit \u5b89\u88c5 git 64bit\u5de5\u5177 git 64 bit \u6253\u5f00\u4e00\u4e2a\u7ec8\u7aef. \u521b\u5efa\u4e00\u4e2a\u9879\u76ee\u76ee\u5f55\u5e76\u8fdb\u5165\u5176\u4e2d. mkdir projects cd projects \u4eceGithub \u4e0b\u8f7d\u6700\u65b0\u7684\u9a74\u8f66\u4ed3\u5e93. git clone https://github.com/autorope/donkeycar cd donkeycar git checkout main \u83b7\u53d6\u7a33\u5b9a\u7248\u672c git clone https://github.com/autorope/donkeycar cd donkeycar git fetch --all --tags latestTag=$(git describe --tags `git rev-list --tags --max-count=1`) git checkout $latestTag \u5982\u679c\u4e0d\u662f\u7b2c\u4e00\u6b21\u5b89\u88c5,\u66f4\u65b0 Conda\u5e76\u4e14\u5220\u9664\u65e7\u7684donkey\u865a\u62df\u73af\u5883 conda update -n base -c defaults conda conda env remove -n donkey \u521b\u5efaPython anaconda\u865a\u62df\u73af\u5883 conda env create -f install/envs/mac.yml conda activate donkey pip install -e .[pc] \u5b89\u88c5 mamba \u5e76\u901a\u8fc7 mac.yml \u6587\u4ef6\u5b89\u88c5 pyhton \u7684\u4f9d\u8d56\u5e93. conda install mamba -n base -c conda-forge mamba env create -f install/envs/mac.yml conda activate donkey pip install -e .[pc] \u6ce8\u610f: \u5982\u679c\u4f60\u662f\u7528 ZSH \u7684 shell, \u9700\u8981\u8f6c\u4e49\u4e00\u4e0b[pc],\u56e0\u6b64\u4f60\u9700\u8981\u8f93\u5165\u7684\u4e0d\u662f pip install -e . [pc] \u800c\u662f pip install -e . \\[pc\\] [\u53ef\u9009]\u5b89\u88c5 Tensorflow GPU - \u4ec5\u5f53NVidia \u56fe\u5f62\u52a0\u901f\u5361\u7684\u65f6\u5019. \u4f60\u9700\u8981\u5148\u5b89\u88c5NVidia GPU\u7684\u6700\u65b0\u9a71\u52a8,\u5177\u4f53\u53c2\u8003\u4f60\u663e\u5361\u7684\u7c7b\u578b\u53bb\u82f1\u4f1f\u8fbe\u5b98\u65b9\u7ad9\u70b9\u5bfb\u627e. Conda \u4f1a\u5904\u7406\u5e76\u5b89\u88c5\u6b63\u786e\u7684 cuda \u548c cuddn \u7684\u5e93\u6765\u5339\u914d\u4f60\u7684 Tensorflow \u7248\u672c. conda install tensorflow-gpu==2.2.0 Tensorflow GPU \u4e0d\u8fc7\u53ef\u60dc\u7684\u662f\u5f53\u524d\u4f3c\u4e4e\u6ca1\u6709NVidia gpu \u80fd\u5728 Mac \u4e0a\u652f\u6301 tensorflow, \u8be6\u60c5\u8bf7\u53c2\u8003: tensorflow on mac . \u521b\u5efa\u4f60\u672c\u5730\u7684\u5de5\u4f5c\u76ee\u5f55: donkey createcar --path ../mycar DonkeyGYM \u5b89\u88c5\u914d\u7f6e \u60a8\u53ef\u4ee5\u901a\u8fc7\u5c06\u6a21\u62df\u5668\u89c6\u4e3a\u865a\u62df\u786c\u4ef6\u6765\u4e86\u89e3\u548c\u4f7f\u7528\u6807\u51c6\u7684 Donkeycar \u9a7e\u9a76/\u8bad\u7ec3/\u6d4b\u8bd5\u7684\u6574\u4e2a\u6d41\u7a0b \u60a8\u5c06\u4f7f\u7528\u4e0e\u4f7f\u7528\u771f\u5b9e\u9a74\u8f66\u76f8\u540c\u7684\u547d\u4ee4\u6765\u6536\u96c6\u6570\u636e\u3001\u9a7e\u9a76\u548c\u8bad\u7ec3\u3002 \u5b89\u88c5 \u4ece Donkey Gym Release \u4e0b\u8f7d\u6a21\u62df\u5668\u5e76\u89e3\u538b\u5230\u9a74\u8f66\u9879\u76ee\u76ee\u5f55. \u5efa\u8bae\u5c06\u5b89\u88c5\u8def\u5f84\u9ed8\u8ba4\u653e\u7f6e\u5728: ~/projects/DonkeySimLinux \u786e\u4fdd\u5b8c\u6210\u4e86donkeycar\u9a74\u8f66\u7684\u73af\u5883\u914d\u7f6e\u6b65\u9aa4,\u5982\u679c\u672a\u5b8c\u6210\u8bf7 \u5b89\u88c5Donkeycar\u73af\u5883 \u8bbe\u7f6e DonkeyGym\uff1a cd ~/projects git clone https://github.com/tawnkramer/gym-donkeycar cd gym-donkeycar conda activate donkey pip install -e .[gym-donkeycar] \u4f60\u53ef\u4ee5\u4f7f\u7528\u4e4b\u524d\u521b\u5efa\u7684\u9a74\u8f66\u5b9e\u4f8b\u73af\u5883 mycar ,\u4f46\u662f\u4e3a\u4e86\u4fbf\u4e8e\u533a\u5206,\u6211\u4eec\u5efa\u8bae\u65b0\u521b\u5efa\u4e00\u4e2a\u6a21\u62df\u5668\u7684\u5b9e\u4f8b. donkey createcar --path ../mysim cd ../mysim \u7f16\u8f91\u4f60\u7684 myconfig.py \u53bb\u542f\u7528 Donkey GYM \u73af\u5883.\u66ff\u6362 <user-name> \u548c\u5176\u4ed6\u90e8\u5206\u7684\u8def\u5f84, \u4f8b\u5982\u4f60\u7684 donkey_sim \u7684\u6a21\u62df\u5668\u7684\u4f4d\u7f6e: ** \u672c\u5730\u6a21\u62df\u5668 \u672c\u5730\u6a21\u62df\u5668\u8868\u793a\u60a8\u5c06\u4f7f\u7528\u60a8\u672c\u5730\u7684\u6a21\u62df\u5668\u73af\u5883\u8fdb\u884c\u9a74\u8f66\u7684\u6570\u636e\u91c7\u96c6, \u8bad\u7ec3,\u81ea\u52a8\u9a7e\u9a76\u7b49\u64cd\u4f5c. DONKEY_GYM = True DONKEY_SIM_PATH = \"/home/<user-name>/projects/DonkeySimLinux/donkey_sim.x86_64\" DONKEY_GYM_ENV_NAME = \"donkey-generated-track-v0\" ** \u8fdc\u7a0b\u6a21\u62df\u5668 \u8fdc\u7a0b\u6a21\u62df\u5668\u5c31\u662f\u5141\u8bb8\u60a8\u901a\u8fc7\u4e92\u8054\u7f51\u8fde\u5165\u9a74\u8f66\u670d\u52a1\u5668\u5e76\u548c\u4e92\u8054\u7f51\u4e0a\u7684\u7528\u6237\u8fdb\u884c\u9a74\u8f66\u6a21\u62df\u9a7e\u9a76,\u540c\u65f6\u91c7\u96c6\u6570\u636e\u5230\u672c\u5730,\u91c7\u96c6\u5b8c\u6210\u540e,\u53ef\u4ee5\u5728\u672c\u5730\u5b8c\u6210\u6570\u636e\u7b5b\u9009\u548c\u6a21\u578b\u8bad\u7ec3. \u7136\u540e\u518d\u5229\u7528\u8bad\u7ec3\u597d\u7684\u6a21\u578b\u8fdb\u884c\u6bd4\u8d5b. WEB_CONTROL_PORT = 8880 WEB_INIT_MODE = \"local\" DONKEY_GYM = True DONKEY_GYM_ENV_NAME = \"donkey-generated-track-v0\" DONKEY_SIM_PATH = \"remote\" SIM_HOST = \"race.donkeydrift.com\" SIM_PORT = 9091 GYM_CONF = { \"body_style\" : \"car01\", \"body_rgb\" : (255, 0, 255), \"car_name\" : \"<YOUR_NAME>\", \"font_size\" : 100} GYM_CONF[\"racer_name\"] = \"<YOUR_NAME>\" GYM_CONF[\"country\"] = \"Shanghai\" GYM_CONF[\"bio\"] = \"<YOUR_BIO>\" GYM_CONF[\"guid\"] = \"0\" \u6ce8\u610f: \u8fd9\u91cc\u7684\u4e3b\u8981\u9700\u8981\u8bbe\u7f6e DONKEY_SIM_PATH = \"remote\" \u53e6\u5916\u5bf9\u4e8e\u672c\u5730\u7528\u6237\u7684 DONKEY_SIM_PATH\u8bbe\u7f6e\u4e00\u5b9a\u662f DonkeySimLinux \u6a21\u62df\u5668\u5b89\u88c5\u7684\u8def\u5f84. Windows: DonkeySimWin/donkey_sim.exe Mac OS: DonkeySimMac/donkey_sim.app/Contents/MacOS/donkey_sim Linux: DonkeySimLinux/donkey_sim.x86_64 Mac OS \u548c Linux \u7cfb\u7edf\u4e2d,\u9700\u8981\u5bf9\u6a21\u62df\u5668\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u8d4b\u6743. chmod +x DonkeySimMac/donkey_sim.app/Contents/MacOS/donkey_sim \u6216 chmod +x DonkeySimLinux/donkey_sim.x86_64 \u9a7e\u9a76 \u5728\u786e\u4fdd\u5f53\u524d\u73af\u5883\u5728 donkey \u7684\u865a\u62df\u73af\u5883\u4e0b\u7684\u60c5\u51b5\u4e0b,\u5c31\u662f\u7ec8\u7aef\u547d\u4ee4\u63d0\u793a\u7b26\u524d\u65b9\u7c7b\u4f3c: (donkey)[username@localhost ~]$ \u5982\u679c\u662f (base) , \u8bf7\u5728\u7ec8\u7aef\u8f93\u5165: conda activate donkey \u542f\u52a8\u9a7e\u9a76: python manage.py drive \u8fd9\u65f6\u5019,\u5f53\u4f60\u7684\u6a21\u62df\u5668\u662f\u672c\u5730\u6a21\u62df\u5668\u7684\u65f6\u5019,\u4f1a\u81ea\u52a8\u542f\u52a8 unity\u7684\u7a0b\u5e8f,\u5e76\u53ef\u4ee5\u901a\u8fc7\u7f51\u9875\u7aef\u8bbf\u95ee http://localhost:8887/drive \u770b\u5230\u63a7\u5236\u9875\u9762. \u5982\u679c\u60a8\u76ee\u524d\u6709\u4e00\u4e2a PS3/XBOX \u624b\u67c4, \u90a3\u4e48\u53ef\u4ee5\u63a5\u5165\u4f60\u7684\u7535\u8111,\u5728\u7f51\u9875\u7aef\u9009\u62e9 joystick \u65b9\u5f0f\u8fdb\u884c\u63a7\u5236.\u53ea\u6709\u5728 Ubuntu Linux\u4e0b, \u4f60\u53ef\u4ee5\u63d2\u5165\u4f60\u7684\u624b\u67c4,\u5728\u7cfb\u7edf\u4e2d\u4f1a\u8bc6\u522b\u6210\u4e00\u4e2a\u5b57\u7b26\u8bbe\u5907, \u4f4d\u7f6e\u5728 /dev/input/js0 \u4f60\u53ef\u4ee5\u7f16\u8f91 myconfig.py \u6587\u4ef6\u53bb\u6dfb\u52a0\u4f60\u7684\u6447\u6746\u7684\u6a21\u578b\u548c\u4f7f\u7528 --js \u53c2\u6570\u6765\u8fd0\u884c\u9a7e\u9a76\u65f6\u4f7f\u7528\u7684\u7a0b\u5e8f. python manage.py drive --js \u5728\u6a21\u62df\u5668\u4e2d\u7684\u8f66\u8f86\u884c\u9a76\u8d77\u6765\u540e, \u5b83\u5c06\u4f1a\u5728\u672c\u5730\u7684 data \u76ee\u5f55\u4e2d\u521b\u5efa tub \u8bb0\u5f55,\u8fd9\u91cc\u7684\u8bb0\u5f55\u91cc\u9762\u5305\u542b\u56fe\u7247,\u5f53\u524d\u7684\u6cb9\u95e8\u548c\u8f6c\u5411\u4fe1\u606f. \u8bad\u7ec3 \u672c\u5730\u8bad\u7ec3 \u5982\u679c\u60a8\u672c\u5730\u4e3b\u673a\u6027\u80fd\u5353\u8d8a,\u5e76\u4e14\u5f53\u524d\u60a8\u6ca1\u6709\u8fdc\u7a0b\u4e91\u7aef\u670d\u52a1\u5668\u63d0\u4f9b\u8bad\u7ec3\u670d\u52a1,\u60a8\u53ef\u4ee5\u76f4\u63a5\u5728\u672c\u5730\u5bf9\u6570\u636e\u96c6\u8fdb\u884c\u8bad\u7ec3\u5e76\u751f\u6210\u4f60\u60f3\u8981\u7684\u6a21\u578b. donkey train --tub ./data --model models/mypilot.h5 Azure\u4e91\u7aef\u8bad\u7ec3 \u5982\u679c\u4f7f\u7528 Azure \u4e91\u7aef\u4e3b\u673a\u8fdb\u884c\u8bad\u7ec3,\u5219\u9700\u8981\u5c06\u6570\u636e\u6253\u5305\u5e76\u901a\u8fc7 scp \u7b49\u8fdc\u7a0b\u4f20\u8f93\u7684\u65b9\u5f0f\u4f20\u8f93\u5230\u4e91\u7aef\u7684\u9a74\u8f66\u73af\u5883\u4e2d\u8fdb\u884c\u8bad\u7ec3, \u8bad\u7ec3\u7684\u547d\u4ee4\u4e0e\u672c\u5730\u8bad\u7ec3\u4e00\u81f4. \u6253\u5305\u6570\u636e\u5e76\u4e0a\u4f20\u4e91\u7aef\u547d\u4ee4\u7c7b\u4f3c: tar -cvzf data.tar.gz ./data scp -i donkeycar.pem -P50001 data.tar.gz azureuser@\u4e91\u7aef\u4e3b\u673a IP \u5730\u5740( \u6bd4\u8d5b\u524d\u4f1a\u5206\u53d1\u7ed9\u5404\u4f4d\u9009\u624b):/home/azureuser/ \u6d4b\u8bd5\u8bad\u7ec3\u6548\u679c(\u81ea\u52a8\u9a7e\u9a76) \u548c\u9a7e\u9a76\u65f6\u4f7f\u7528\u7684\u547d\u4ee4\u7c7b\u4f3c, \u53ea\u662f\u5728\u81ea\u52a8\u9a7e\u9a76\u65f6,\u6dfb\u52a0 --model \u53c2\u6570\u53ca\u6a21\u578b\u6587\u4ef6\u7684\u76f8\u5bf9\u8def\u5f84. python manage.py drive --model models/mypilot.h5 \u7136\u540e\u901a\u8fc7\u7f51\u9875\u63a7\u5236\u7aef,\u8bbe\u7f6e Mode and Pilot \u4e3a Full Pilot , \u8fd9\u65f6\u5019\u6a21\u62df\u7684\u9a74\u8f66\u5c31\u5f00\u59cb\u81ea\u52a8\u9a7e\u9a76\u4e86.","title":"\u6a21\u62df\u8bad\u7ec3"},{"location":"donkeygym/gym_simulator/#_1","text":"Donkey Gym\u9879\u76ee\u662f\u56f4\u7ed5\u81ea\u9a7e\u6c99\u76d2\u9a74\u6a21\u62df\u5668 ( )\u7684OpenAI. \u4ece\u6e90\u4ee3\u7801\u6784\u5efa\u6a21\u62df\u5668\u65f6\uff0c\u9700\u8981\u68c0\u67e5\u9879\u76ee\u7684donkey\u5206\u652f\u7684sdsandbox\u3002 \u8be5\u6a21\u62df\u5668\u5efa\u7acb\u5728Unity\u6e38\u620f\u5e73\u53f0\u4e0a\uff0c\u4f7f\u7528\u5176\u5185\u90e8\u7269\u7406\u548c\u56fe\u5f62\uff0c\u5e76\u8fde\u63a5\u5230\u9a74\u8f66Python\u8fdb\u7a0b\uff0c\u4ee5\u4f7f\u7528\u6211\u4eec\u8bad\u7ec3\u7684\u6a21\u578b\u6765\u63a7\u5236\u6a21\u62df\u7684\u9a74\u8f66. \u751a\u81f3\u901a\u8fc7\u811a\u672c\u4e2d\u7684 multitrain.py \u521b\u5efa\u591a\u4e2a AI \u5c0f\u8f66\u8fdb\u884c\u591a\u8f66\u540c\u65f6\u8dd1\u6a21\u62df\u5668\u73af\u5883\u8fdb\u884c\u8bad\u7ec3. \u5177\u4f53\u53c2\u89c1/donkeycar/donkeycar/scripts/multitrain.py","title":"\u9a74\u8f66\u6a21\u62df\u5668"},{"location":"donkeygym/gym_simulator/#_2","text":"","title":"\u6a21\u62df\u5668\u5b89\u88c5\u914d\u7f6e"},{"location":"donkeygym/gym_simulator/#windows","text":"","title":"Windows\u7cfb\u7edf"},{"location":"donkeygym/gym_simulator/#_3","text":"\u6ce8\u610f: \u5df2\u5728Windows 10\u4e0a\u6d4b\u8bd5\u8fc7. TBD","title":"\u5b89\u88c5\u73af\u5883\u4f9d\u8d56"},{"location":"donkeygym/gym_simulator/#linux","text":"","title":"Linux \u7cfb\u7edf"},{"location":"donkeygym/gym_simulator/#_4","text":"\u6ce8\u610f: \u5df2\u5728Ubuntu 20.04 LTS\u4e0a\u6d4b\u8bd5\u8fc7. \u6253\u5f00\u4e00\u4e2a\u7ec8\u7aef(\u5feb\u6377\u952e Ctrl+ Alt + T) \u4e0b\u8f7d\u5e76\u5b89\u88c5miniconda python3.7 64bit\u7248\u672c miniconda Python 3.7 64 bit . wget https://repo.anaconda.com/miniconda/Miniconda3-latest-Linux-x86_64.sh bash ./Miniconda3-latest-Linux-x86_64.sh \u521b\u5efa\u9879\u76ee\u76ee\u5f55\u5e76\u8fdb\u5165\u76ee\u5f55 mkdir projects cd projects \u4ece Github \u4e0a\u4e0b\u8f7d\u6700\u65b0\u7684donkeycar \u4ed3\u5e93. git clone https://github.com/autorope/donkeycar cd donkeycar git checkout main \u83b7\u53d6\u7a33\u5b9a\u7248\u672c git clone https://github.com/autorope/donkeycar cd donkeycar git fetch --all --tags latestTag=$(git describe --tags `git rev-list --tags --max-count=1`) git checkout $latestTag \u5982\u679c\u4e0d\u662f\u7b2c\u4e00\u6b21\u5b89\u88c5donkeycar,\u9700\u8981\u66f4\u65b0Conda\u73af\u5883\u548c\u79fb\u9664\u65e7\u7684donkey\u5e93. conda update -n base -c defaults conda conda env remove -n donkey \u521b\u5efa Python anaconda \u7684\u73af\u5883 conda env create -f install/envs/ubuntu.yml conda activate donkey pip install -e .[pc] \u6211\u4eec\u89c2\u5bdf\u5230 conda \u8fdb\u884c\u5b89\u88c5\u7684\u65f6\u5019\u975e\u5e38\u6162, \u4e24\u79cd\u65b9\u6cd5,\u4e00\u79cd\u662f\u6362 mamba ,\u4e00\u79cd\u5c31\u6362 Conda\u6e90. conda install mamba -n base -c conda-forge mamba env create -f install/envs/ubuntu.yml conda activate donkey pip install -e .[pc] \u6ce8\u610f: \u5982\u679c\u4f60\u662f\u7528 ZSH \u7684 shell, \u9700\u8981\u8f6c\u4e49\u4e00\u4e0b[pc],\u56e0\u6b64\u4f60\u9700\u8981\u8f93\u5165\u7684\u4e0d\u662f pip install -e . [pc] \u800c\u662f pip install -e . \\[pc\\] [\u53ef\u9009]\u5b89\u88c5 Tensorflow GPU - \u4ec5\u5f53\u4f60\u62e5\u6709 NVidia \u56fe\u5f62\u52a0\u901f\u5361\u7684\u65f6\u5019. \u4f60\u9700\u8981\u5148\u5b89\u88c5NVidia GPU\u7684\u6700\u65b0\u9a71\u52a8,\u5177\u4f53\u53c2\u8003\u4f60\u663e\u5361\u7684\u7c7b\u578b\u53bb\u82f1\u4f1f\u8fbe\u5b98\u65b9\u7ad9\u70b9\u5bfb\u627e. Conda \u4f1a\u5904\u7406\u5e76\u5b89\u88c5\u6b63\u786e\u7684 cuda \u548c cuddn \u7684\u5e93\u6765\u5339\u914d\u4f60\u7684 Tensorflow \u7248\u672c. conda install tensorflow-gpu==2.2.0 \u521b\u5efa\u4f60\u672c\u5730\u7684\u5de5\u4f5c\u76ee\u5f55: cd projects/donkeycar donkey createcar --path ../mycar \u6ce8\u610f:\u5982\u679c\u5173\u95ed\u4e86 Anaconda \u63d0\u793a\u7b26\u540e,\u91cd\u65b0\u6253\u5f00\u5c31\u9700\u8981\u8f93\u5165: \u8f93\u5165 conda activate donkey \u53bb\u91cd\u65b0\u6620\u5c04\u5230 donkey \u7684\u865a\u62df\u73af\u5883\u4e2d.","title":"\u5b89\u88c5\u73af\u5883\u4f9d\u8d56"},{"location":"donkeygym/gym_simulator/#macos","text":"\u5df2\u7ecf\u5728 macOS Big Sur 11.6.5 \u73af\u5883\u4e0b\u6d4b\u8bd5\u901a\u8fc7.","title":"MacOS \u7cfb\u7edf"},{"location":"donkeygym/gym_simulator/#_5","text":"\u5b89\u88c5 miniconda Python 3.7 64bit \u7248\u672c miniconda Python 3.7 64 bit \u5b89\u88c5 git 64bit\u5de5\u5177 git 64 bit \u6253\u5f00\u4e00\u4e2a\u7ec8\u7aef. \u521b\u5efa\u4e00\u4e2a\u9879\u76ee\u76ee\u5f55\u5e76\u8fdb\u5165\u5176\u4e2d. mkdir projects cd projects \u4eceGithub \u4e0b\u8f7d\u6700\u65b0\u7684\u9a74\u8f66\u4ed3\u5e93. git clone https://github.com/autorope/donkeycar cd donkeycar git checkout main \u83b7\u53d6\u7a33\u5b9a\u7248\u672c git clone https://github.com/autorope/donkeycar cd donkeycar git fetch --all --tags latestTag=$(git describe --tags `git rev-list --tags --max-count=1`) git checkout $latestTag \u5982\u679c\u4e0d\u662f\u7b2c\u4e00\u6b21\u5b89\u88c5,\u66f4\u65b0 Conda\u5e76\u4e14\u5220\u9664\u65e7\u7684donkey\u865a\u62df\u73af\u5883 conda update -n base -c defaults conda conda env remove -n donkey \u521b\u5efaPython anaconda\u865a\u62df\u73af\u5883 conda env create -f install/envs/mac.yml conda activate donkey pip install -e .[pc] \u5b89\u88c5 mamba \u5e76\u901a\u8fc7 mac.yml \u6587\u4ef6\u5b89\u88c5 pyhton \u7684\u4f9d\u8d56\u5e93. conda install mamba -n base -c conda-forge mamba env create -f install/envs/mac.yml conda activate donkey pip install -e .[pc] \u6ce8\u610f: \u5982\u679c\u4f60\u662f\u7528 ZSH \u7684 shell, \u9700\u8981\u8f6c\u4e49\u4e00\u4e0b[pc],\u56e0\u6b64\u4f60\u9700\u8981\u8f93\u5165\u7684\u4e0d\u662f pip install -e . [pc] \u800c\u662f pip install -e . \\[pc\\] [\u53ef\u9009]\u5b89\u88c5 Tensorflow GPU - \u4ec5\u5f53NVidia \u56fe\u5f62\u52a0\u901f\u5361\u7684\u65f6\u5019. \u4f60\u9700\u8981\u5148\u5b89\u88c5NVidia GPU\u7684\u6700\u65b0\u9a71\u52a8,\u5177\u4f53\u53c2\u8003\u4f60\u663e\u5361\u7684\u7c7b\u578b\u53bb\u82f1\u4f1f\u8fbe\u5b98\u65b9\u7ad9\u70b9\u5bfb\u627e. Conda \u4f1a\u5904\u7406\u5e76\u5b89\u88c5\u6b63\u786e\u7684 cuda \u548c cuddn \u7684\u5e93\u6765\u5339\u914d\u4f60\u7684 Tensorflow \u7248\u672c. conda install tensorflow-gpu==2.2.0 Tensorflow GPU \u4e0d\u8fc7\u53ef\u60dc\u7684\u662f\u5f53\u524d\u4f3c\u4e4e\u6ca1\u6709NVidia gpu \u80fd\u5728 Mac \u4e0a\u652f\u6301 tensorflow, \u8be6\u60c5\u8bf7\u53c2\u8003: tensorflow on mac . \u521b\u5efa\u4f60\u672c\u5730\u7684\u5de5\u4f5c\u76ee\u5f55: donkey createcar --path ../mycar","title":"\u5b89\u88c5\u73af\u5883\u4f9d\u8d56"},{"location":"donkeygym/gym_simulator/#donkeygym","text":"\u60a8\u53ef\u4ee5\u901a\u8fc7\u5c06\u6a21\u62df\u5668\u89c6\u4e3a\u865a\u62df\u786c\u4ef6\u6765\u4e86\u89e3\u548c\u4f7f\u7528\u6807\u51c6\u7684 Donkeycar \u9a7e\u9a76/\u8bad\u7ec3/\u6d4b\u8bd5\u7684\u6574\u4e2a\u6d41\u7a0b \u60a8\u5c06\u4f7f\u7528\u4e0e\u4f7f\u7528\u771f\u5b9e\u9a74\u8f66\u76f8\u540c\u7684\u547d\u4ee4\u6765\u6536\u96c6\u6570\u636e\u3001\u9a7e\u9a76\u548c\u8bad\u7ec3\u3002 \u5b89\u88c5 \u4ece Donkey Gym Release \u4e0b\u8f7d\u6a21\u62df\u5668\u5e76\u89e3\u538b\u5230\u9a74\u8f66\u9879\u76ee\u76ee\u5f55. \u5efa\u8bae\u5c06\u5b89\u88c5\u8def\u5f84\u9ed8\u8ba4\u653e\u7f6e\u5728: ~/projects/DonkeySimLinux \u786e\u4fdd\u5b8c\u6210\u4e86donkeycar\u9a74\u8f66\u7684\u73af\u5883\u914d\u7f6e\u6b65\u9aa4,\u5982\u679c\u672a\u5b8c\u6210\u8bf7 \u5b89\u88c5Donkeycar\u73af\u5883 \u8bbe\u7f6e DonkeyGym\uff1a cd ~/projects git clone https://github.com/tawnkramer/gym-donkeycar cd gym-donkeycar conda activate donkey pip install -e .[gym-donkeycar] \u4f60\u53ef\u4ee5\u4f7f\u7528\u4e4b\u524d\u521b\u5efa\u7684\u9a74\u8f66\u5b9e\u4f8b\u73af\u5883 mycar ,\u4f46\u662f\u4e3a\u4e86\u4fbf\u4e8e\u533a\u5206,\u6211\u4eec\u5efa\u8bae\u65b0\u521b\u5efa\u4e00\u4e2a\u6a21\u62df\u5668\u7684\u5b9e\u4f8b. donkey createcar --path ../mysim cd ../mysim \u7f16\u8f91\u4f60\u7684 myconfig.py \u53bb\u542f\u7528 Donkey GYM \u73af\u5883.\u66ff\u6362 <user-name> \u548c\u5176\u4ed6\u90e8\u5206\u7684\u8def\u5f84, \u4f8b\u5982\u4f60\u7684 donkey_sim \u7684\u6a21\u62df\u5668\u7684\u4f4d\u7f6e: ** \u672c\u5730\u6a21\u62df\u5668 \u672c\u5730\u6a21\u62df\u5668\u8868\u793a\u60a8\u5c06\u4f7f\u7528\u60a8\u672c\u5730\u7684\u6a21\u62df\u5668\u73af\u5883\u8fdb\u884c\u9a74\u8f66\u7684\u6570\u636e\u91c7\u96c6, \u8bad\u7ec3,\u81ea\u52a8\u9a7e\u9a76\u7b49\u64cd\u4f5c. DONKEY_GYM = True DONKEY_SIM_PATH = \"/home/<user-name>/projects/DonkeySimLinux/donkey_sim.x86_64\" DONKEY_GYM_ENV_NAME = \"donkey-generated-track-v0\" ** \u8fdc\u7a0b\u6a21\u62df\u5668 \u8fdc\u7a0b\u6a21\u62df\u5668\u5c31\u662f\u5141\u8bb8\u60a8\u901a\u8fc7\u4e92\u8054\u7f51\u8fde\u5165\u9a74\u8f66\u670d\u52a1\u5668\u5e76\u548c\u4e92\u8054\u7f51\u4e0a\u7684\u7528\u6237\u8fdb\u884c\u9a74\u8f66\u6a21\u62df\u9a7e\u9a76,\u540c\u65f6\u91c7\u96c6\u6570\u636e\u5230\u672c\u5730,\u91c7\u96c6\u5b8c\u6210\u540e,\u53ef\u4ee5\u5728\u672c\u5730\u5b8c\u6210\u6570\u636e\u7b5b\u9009\u548c\u6a21\u578b\u8bad\u7ec3. \u7136\u540e\u518d\u5229\u7528\u8bad\u7ec3\u597d\u7684\u6a21\u578b\u8fdb\u884c\u6bd4\u8d5b. WEB_CONTROL_PORT = 8880 WEB_INIT_MODE = \"local\" DONKEY_GYM = True DONKEY_GYM_ENV_NAME = \"donkey-generated-track-v0\" DONKEY_SIM_PATH = \"remote\" SIM_HOST = \"race.donkeydrift.com\" SIM_PORT = 9091 GYM_CONF = { \"body_style\" : \"car01\", \"body_rgb\" : (255, 0, 255), \"car_name\" : \"<YOUR_NAME>\", \"font_size\" : 100} GYM_CONF[\"racer_name\"] = \"<YOUR_NAME>\" GYM_CONF[\"country\"] = \"Shanghai\" GYM_CONF[\"bio\"] = \"<YOUR_BIO>\" GYM_CONF[\"guid\"] = \"0\" \u6ce8\u610f: \u8fd9\u91cc\u7684\u4e3b\u8981\u9700\u8981\u8bbe\u7f6e DONKEY_SIM_PATH = \"remote\" \u53e6\u5916\u5bf9\u4e8e\u672c\u5730\u7528\u6237\u7684 DONKEY_SIM_PATH\u8bbe\u7f6e\u4e00\u5b9a\u662f DonkeySimLinux \u6a21\u62df\u5668\u5b89\u88c5\u7684\u8def\u5f84. Windows: DonkeySimWin/donkey_sim.exe Mac OS: DonkeySimMac/donkey_sim.app/Contents/MacOS/donkey_sim Linux: DonkeySimLinux/donkey_sim.x86_64 Mac OS \u548c Linux \u7cfb\u7edf\u4e2d,\u9700\u8981\u5bf9\u6a21\u62df\u5668\u7684\u4e8c\u8fdb\u5236\u6587\u4ef6\u8d4b\u6743. chmod +x DonkeySimMac/donkey_sim.app/Contents/MacOS/donkey_sim \u6216 chmod +x DonkeySimLinux/donkey_sim.x86_64","title":"DonkeyGYM \u5b89\u88c5\u914d\u7f6e"},{"location":"donkeygym/gym_simulator/#_6","text":"\u5728\u786e\u4fdd\u5f53\u524d\u73af\u5883\u5728 donkey \u7684\u865a\u62df\u73af\u5883\u4e0b\u7684\u60c5\u51b5\u4e0b,\u5c31\u662f\u7ec8\u7aef\u547d\u4ee4\u63d0\u793a\u7b26\u524d\u65b9\u7c7b\u4f3c: (donkey)[username@localhost ~]$ \u5982\u679c\u662f (base) , \u8bf7\u5728\u7ec8\u7aef\u8f93\u5165: conda activate donkey \u542f\u52a8\u9a7e\u9a76: python manage.py drive \u8fd9\u65f6\u5019,\u5f53\u4f60\u7684\u6a21\u62df\u5668\u662f\u672c\u5730\u6a21\u62df\u5668\u7684\u65f6\u5019,\u4f1a\u81ea\u52a8\u542f\u52a8 unity\u7684\u7a0b\u5e8f,\u5e76\u53ef\u4ee5\u901a\u8fc7\u7f51\u9875\u7aef\u8bbf\u95ee http://localhost:8887/drive \u770b\u5230\u63a7\u5236\u9875\u9762. \u5982\u679c\u60a8\u76ee\u524d\u6709\u4e00\u4e2a PS3/XBOX \u624b\u67c4, \u90a3\u4e48\u53ef\u4ee5\u63a5\u5165\u4f60\u7684\u7535\u8111,\u5728\u7f51\u9875\u7aef\u9009\u62e9 joystick \u65b9\u5f0f\u8fdb\u884c\u63a7\u5236.\u53ea\u6709\u5728 Ubuntu Linux\u4e0b, \u4f60\u53ef\u4ee5\u63d2\u5165\u4f60\u7684\u624b\u67c4,\u5728\u7cfb\u7edf\u4e2d\u4f1a\u8bc6\u522b\u6210\u4e00\u4e2a\u5b57\u7b26\u8bbe\u5907, \u4f4d\u7f6e\u5728 /dev/input/js0 \u4f60\u53ef\u4ee5\u7f16\u8f91 myconfig.py \u6587\u4ef6\u53bb\u6dfb\u52a0\u4f60\u7684\u6447\u6746\u7684\u6a21\u578b\u548c\u4f7f\u7528 --js \u53c2\u6570\u6765\u8fd0\u884c\u9a7e\u9a76\u65f6\u4f7f\u7528\u7684\u7a0b\u5e8f. python manage.py drive --js \u5728\u6a21\u62df\u5668\u4e2d\u7684\u8f66\u8f86\u884c\u9a76\u8d77\u6765\u540e, \u5b83\u5c06\u4f1a\u5728\u672c\u5730\u7684 data \u76ee\u5f55\u4e2d\u521b\u5efa tub \u8bb0\u5f55,\u8fd9\u91cc\u7684\u8bb0\u5f55\u91cc\u9762\u5305\u542b\u56fe\u7247,\u5f53\u524d\u7684\u6cb9\u95e8\u548c\u8f6c\u5411\u4fe1\u606f.","title":"\u9a7e\u9a76"},{"location":"donkeygym/gym_simulator/#_7","text":"\u672c\u5730\u8bad\u7ec3 \u5982\u679c\u60a8\u672c\u5730\u4e3b\u673a\u6027\u80fd\u5353\u8d8a,\u5e76\u4e14\u5f53\u524d\u60a8\u6ca1\u6709\u8fdc\u7a0b\u4e91\u7aef\u670d\u52a1\u5668\u63d0\u4f9b\u8bad\u7ec3\u670d\u52a1,\u60a8\u53ef\u4ee5\u76f4\u63a5\u5728\u672c\u5730\u5bf9\u6570\u636e\u96c6\u8fdb\u884c\u8bad\u7ec3\u5e76\u751f\u6210\u4f60\u60f3\u8981\u7684\u6a21\u578b. donkey train --tub ./data --model models/mypilot.h5 Azure\u4e91\u7aef\u8bad\u7ec3 \u5982\u679c\u4f7f\u7528 Azure \u4e91\u7aef\u4e3b\u673a\u8fdb\u884c\u8bad\u7ec3,\u5219\u9700\u8981\u5c06\u6570\u636e\u6253\u5305\u5e76\u901a\u8fc7 scp \u7b49\u8fdc\u7a0b\u4f20\u8f93\u7684\u65b9\u5f0f\u4f20\u8f93\u5230\u4e91\u7aef\u7684\u9a74\u8f66\u73af\u5883\u4e2d\u8fdb\u884c\u8bad\u7ec3, \u8bad\u7ec3\u7684\u547d\u4ee4\u4e0e\u672c\u5730\u8bad\u7ec3\u4e00\u81f4. \u6253\u5305\u6570\u636e\u5e76\u4e0a\u4f20\u4e91\u7aef\u547d\u4ee4\u7c7b\u4f3c: tar -cvzf data.tar.gz ./data scp -i donkeycar.pem -P50001 data.tar.gz azureuser@\u4e91\u7aef\u4e3b\u673a IP \u5730\u5740( \u6bd4\u8d5b\u524d\u4f1a\u5206\u53d1\u7ed9\u5404\u4f4d\u9009\u624b):/home/azureuser/","title":"\u8bad\u7ec3"},{"location":"donkeygym/gym_simulator/#_8","text":"\u548c\u9a7e\u9a76\u65f6\u4f7f\u7528\u7684\u547d\u4ee4\u7c7b\u4f3c, \u53ea\u662f\u5728\u81ea\u52a8\u9a7e\u9a76\u65f6,\u6dfb\u52a0 --model \u53c2\u6570\u53ca\u6a21\u578b\u6587\u4ef6\u7684\u76f8\u5bf9\u8def\u5f84. python manage.py drive --model models/mypilot.h5 \u7136\u540e\u901a\u8fc7\u7f51\u9875\u63a7\u5236\u7aef,\u8bbe\u7f6e Mode and Pilot \u4e3a Full Pilot , \u8fd9\u65f6\u5019\u6a21\u62df\u7684\u9a74\u8f66\u5c31\u5f00\u59cb\u81ea\u52a8\u9a7e\u9a76\u4e86.","title":"\u6d4b\u8bd5\u8bad\u7ec3\u6548\u679c(\u81ea\u52a8\u9a7e\u9a76)"},{"location":"hardware/hardware_arch/","text":"\u786c\u4ef6\u67b6\u6784 \u786c\u4ef6\u7ec4\u6210 \u89c6\u89c9\u91c7\u96c6\u90e8\u5206: USB \u6444\u50cf\u5934 \u4e3b\u63a7\u90e8\u5206: DFRobot LattePanda v1 X86\u67b6\u6784\u5f00\u53d1\u677f \u5929\u7ebf \u4f9b\u7535\u90e8\u5206: \u5fae\u96ea Ai \u81ea\u52a8\u9a7e\u9a76\u5c0f\u8f66\u4f9b\u7535\u677f \u673a\u68b0\u90e8\u5206: \u5fae\u96ea AI \u81ea\u52a8\u9a7e\u9a76\u5c0f\u8f66\u5e95\u76d8(1:16) RC\u63a7\u5236\u90e8\u5206: \u5c0f\u98de\u8c61\u67aa\u63a7\u5957\u4ef6 Arduino Leonardo \u5f00\u53d1\u677f \u5de5\u5177\u90e8\u5206: M2.5\u87ba\u4e1d\u5200 \u7535\u70d9\u94c1 \u710a\u9521 \u5438\u9521\u5668 \u6d17\u677f\u6c34 \u954a\u5b50 \u53cc\u9762\u80f6 \u675c\u90a6\u7ebf \u624e\u5e26 \u6d4b\u8bd5\u5de5\u5177\u90e8\u5206: HDMI\u7ebf\u7f06 \u652f\u6301 HDMI\u7684\u5c4f\u5e55","title":"\u786c\u4ef6\u67b6\u6784"},{"location":"hardware/hardware_arch/#_1","text":"","title":"\u786c\u4ef6\u67b6\u6784"},{"location":"hardware/hardware_arch/#_2","text":"","title":"\u786c\u4ef6\u7ec4\u6210"},{"location":"hardware/hardware_arch/#_3","text":"USB \u6444\u50cf\u5934","title":"\u89c6\u89c9\u91c7\u96c6\u90e8\u5206:"},{"location":"hardware/hardware_arch/#_4","text":"DFRobot LattePanda v1 X86\u67b6\u6784\u5f00\u53d1\u677f \u5929\u7ebf","title":"\u4e3b\u63a7\u90e8\u5206:"},{"location":"hardware/hardware_arch/#_5","text":"\u5fae\u96ea Ai \u81ea\u52a8\u9a7e\u9a76\u5c0f\u8f66\u4f9b\u7535\u677f","title":"\u4f9b\u7535\u90e8\u5206:"},{"location":"hardware/hardware_arch/#_6","text":"\u5fae\u96ea AI \u81ea\u52a8\u9a7e\u9a76\u5c0f\u8f66\u5e95\u76d8(1:16)","title":"\u673a\u68b0\u90e8\u5206:"},{"location":"hardware/hardware_arch/#rc","text":"\u5c0f\u98de\u8c61\u67aa\u63a7\u5957\u4ef6 Arduino Leonardo \u5f00\u53d1\u677f","title":"RC\u63a7\u5236\u90e8\u5206:"},{"location":"hardware/hardware_arch/#_7","text":"M2.5\u87ba\u4e1d\u5200 \u7535\u70d9\u94c1 \u710a\u9521 \u5438\u9521\u5668 \u6d17\u677f\u6c34 \u954a\u5b50 \u53cc\u9762\u80f6 \u675c\u90a6\u7ebf \u624e\u5e26","title":"\u5de5\u5177\u90e8\u5206:"},{"location":"hardware/hardware_arch/#_8","text":"HDMI\u7ebf\u7f06 \u652f\u6301 HDMI\u7684\u5c4f\u5e55","title":"\u6d4b\u8bd5\u5de5\u5177\u90e8\u5206:"},{"location":"mechanic/mechanic_arch/","text":"\u673a\u68b0\u67b6\u6784 RC\u67aa\u63a7\u5916\u89c2","title":"\u673a\u68b0\u67b6\u6784"},{"location":"mechanic/mechanic_arch/#_1","text":"","title":"\u673a\u68b0\u67b6\u6784"},{"location":"mechanic/mechanic_arch/#rc","text":"","title":"RC\u67aa\u63a7\u5916\u89c2"},{"location":"operation/dk_process/","text":"\u5b89\u88c5\u8fdc\u7a0b\u767b\u5f55\u8f6f\u4ef6 \u4e00\u822c\u60c5\u51b5\u4e0b,\u9a74\u8f66\u5b89\u88c5\u914d\u7f6e\u5b8c\u6210\u540e,\u53ef\u901a\u8fc7Wi-Fi \u8fde\u5165\u7f51\u7edc,\u5efa\u8bae\u901a\u8fc7\u8fdc\u7a0b\u7ec8\u7aef\u8f6f\u4ef6\u767b\u5f55\u9a74\u8f66\u8fdb\u884c\u8c03\u8bd5. \u5e38\u89c1\u8fdc\u7a0b\u767b\u5f55\u8f6f\u4ef6 putty mobaxterm SecureCRT Xshell \u767b\u5f55\u4fe1\u606f \u7528\u6237\u540d: donkeycar \u5bc6\u7801: donkeycar IP\u5730\u5740: \u8bf7\u5728\u6bd4\u8d5b\u73b0\u573a\u8054\u7f51\u540e\u901a\u8fc7\u4e0b\u9762\u547d\u4ee4\u83b7\u53d6. hostname -I \u6216\u8005 ifconfig wlan0 \u9a74\u8f66\u9879\u76ee\u8def\u5f84 \u9a74\u8f66\u9879\u76ee\u4f4d\u4e8e /home/donkeycar/projects \u76ee\u5f55 \u8bf7\u5728\u8fdc\u7a0b\u767b\u5f55\u7cfb\u7edf\u540e,\u901a\u8fc7 cd \u547d\u4ee4\u5207\u6362\u81f3\u8be5\u76ee\u5f55,\u5e76\u786e\u8ba4\u5f53\u524d\u4e3a (donkey) \u865a\u62df\u73af\u5883. \u5982\u679c\u5f53\u524d\u4f4d\u4e8e: (base)[donkeycar@donkeycar0X ~]$ #\u6b64\u65f6\u662fconda \u57fa\u7840\u73af\u5883\u9700\u8981\u5207\u6362\u81f3\u9a74\u8f66\u73af\u5883. conda activate donkey \u5982\u679c\u9700\u8981\u9000\u51fa\u865a\u62df\u73af\u5883\u8bf7\u8f93\u5165: conda deactivate donkey \u542f\u52a8\u9a74\u8f66 \u5728\u7ec8\u7aef\u8f93\u5165: python manage.py drive \u9a74\u8f66\u542f\u52a8\u540e,\u7ec8\u7aef\u4f1a\u88ab\u5360\u7528,\u5982\u679c\u9700\u8981\u7ec8\u6b62\u9a74\u8f66\u8fd0\u884c\u8bf7\u5728\u952e\u76d8\u6309\u4e0b: ctrl + c \u9a74\u8f66\u7f51\u9875\u7aef\u63a7\u5236 \u9ed8\u8ba4\u60c5\u51b5\u4e0b,\u9a74\u8f66\u5728\u542f\u52a8\u540e\u4f1a\u901a\u8fc7 tornado \u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 web \u9875\u9762,\u8be5\u9875\u9762\u53ef\u7528\u4e8e\u76d1\u63a7\u9a74\u8f66\u884c\u9a76\u72b6\u6001\u53ca\u7f51\u9875\u7aef\u63a7\u5236,\u53ef\u901a\u8fc7\u6d4f\u89c8\u5668\u8bbf\u95ee\u9a74\u8f66IP \u5730\u5740\u53ca\u7aef\u53e3\u6765\u83b7\u53d6. * \u7f51\u9875\u7aef\u6253\u5f00 http://\u9a74\u8f66\u5f53\u524dIP\u5730\u5740:8887 \u7aef\u53e3 \u9ed8\u8ba4\u7aef\u53e3: 8887 \u9a74\u8f66\u5728\u9a7e\u9a76\u8fc7\u7a0b\u4e2d,\u4f1a\u4e0d\u65ad\u901a\u8fc7\u6444\u50cf\u5934\u91c7\u96c6\u56fe\u7247\u4fe1\u606f\u5e76\u6574\u5408\u5f53\u524d\u7684\u89d2\u5ea6\u548c\u6cb9\u95e8\u503c\u5b58\u50a8\u5728 data \u76ee\u5f55. \u5728\u6267\u884c\u7ec8\u7aef\u4e2d\u53ef\u4ee5\u901a\u8fc7\u952e\u76d8\u8f93\u5165: CTRL + C \u7ed3\u675f\u91c7\u96c6. \u538b\u7f29\u6253\u5305\u6570\u636e \u4e3a\u4e0a\u4f20\u5230Azure \u8fdb\u884c\u4e91\u7aef\u8fdb\u884c\u8bad\u7ec3,\u52a0\u5feb\u8bad\u7ec3\u8fdb\u7a0b. cd /home/pi/projects/mycar/ tar -czvf data.tar.gz data/ ls \u5982\u679c\u6709 data.tar.gz \u7684\u7ea2\u8272\u538b\u7f29\u5305\u5c31\u597d. \u4e0a\u4f20\u4e91\u4e3b\u673a \u901a\u8fc7 scp \u547d\u4ee4\u62f7\u8d1d scp -P50001 data.tar.gz -i DONKEYCAR_KEY.pem azureuser@AZURE_SERVER_IP:/home/azureuser/mycar/ \u8bad\u7ec3\u65b9\u6cd5 \u89e3\u538b tar -xf data.tar.gz \u8bf7\u786e\u8ba4\u6570\u636e\u5305\u52a0\u538b\u5230 /home/azureuser/mycar/data \u76ee\u5f55. 2. \u8bad\u7ec3 \u5728\u7ec8\u7aef\u4e2d donkey train --tub data/ --model models/donkeycar01.h5 donkeycar01.h5 \u5c31\u662f\u6a21\u578b\u7684\u540d\u5b57, donkeycar01 \u4e3a\u5f53\u524d\u9a74\u8f66\u7684\u4e3b\u673a\u540d. \u8f6c\u6362\u6a21\u578b \u8bad\u7ec3\u5b8c\u6210\u540e\u4f1a\u5728\u9a74\u8f66\u5b9e\u4f8b\u7684 models \u76ee\u5f55\u4e2d\u751f\u6210\u6a21\u578b\u6587\u4ef6. \u7531\u4e8e\u9ed8\u8ba4\u8bad\u7ec3\u51fa\u6765\u7684\u6a21\u578b\u7c7b\u578b\u662f: keras ,\u9700\u8981\u8f6c\u6362\u4e3a tensorflow \u7c7b\u578b,\u518d\u8f6c\u6362\u6210 OpenVINO \u80fd\u8bc6\u522b\u7684\u7c7b\u578b. cd /home/azureuser/projects/traincar/models/ scp -P 50001 azureuser@AZURE_SERVER_IP://home/azureuser/projects/traincar/models/donkeycar01.h5 \u8fd9\u91cc\u7684 -P \u540e\u9762\u586b\u5199\u7684\u670d\u52a1\u5668\u7aef\u53e3\u8bf7\u53c2\u8003\u5bf9\u5e94\u7684\u670d\u52a1\u5668\u7aef\u53e3\u586b\u5199. * 5. \u9a74\u8f66\u81ea\u52a8\u9a7e\u9a76 \u9996\u5148\u8981\u786e\u4fdd\u4f60\u7684\u6a21\u578b\u6587\u4ef6\u653e\u7f6e\u5728\u9a74\u8f66\u7684/home/pi/projects/mycar/models/\u4e0b. \u7136\u540e\u5728\u7ec8\u7aef\u6267\u884c: cd /home/pi/projects/mycar/ python manage.py drive --model models/donkeycar01.h5 \u7f51\u9875\u767b\u9646\u5230\u63a7\u5236\u7ec8\u7aef: http://\u9a74\u8f66\u5f53\u524dIP\u5730\u5740:8887/ \u5148\u70b9\u51fb\u9875\u9762\u4e0b\u65b9\u7684: start vehicle \u6309\u94ae \u7136\u540e\u5728 mode & pilot \u9009\u62e9 local pilot \u5c0f\u8f66\u5c31\u5f00\u59cb\u81ea\u884c\u9a7e\u9a76\u4e86. \u9700\u8981\u7ec8\u6b62\u8bf7\u5728\u7ec8\u7aef\u4e0a\u6309\u4e0b Ctrl + C","title":"\u64cd\u4f5c\u6d41\u7a0b"},{"location":"operation/dk_process/#_1","text":"\u4e00\u822c\u60c5\u51b5\u4e0b,\u9a74\u8f66\u5b89\u88c5\u914d\u7f6e\u5b8c\u6210\u540e,\u53ef\u901a\u8fc7Wi-Fi \u8fde\u5165\u7f51\u7edc,\u5efa\u8bae\u901a\u8fc7\u8fdc\u7a0b\u7ec8\u7aef\u8f6f\u4ef6\u767b\u5f55\u9a74\u8f66\u8fdb\u884c\u8c03\u8bd5.","title":"\u5b89\u88c5\u8fdc\u7a0b\u767b\u5f55\u8f6f\u4ef6"},{"location":"operation/dk_process/#_2","text":"putty mobaxterm SecureCRT Xshell","title":"\u5e38\u89c1\u8fdc\u7a0b\u767b\u5f55\u8f6f\u4ef6"},{"location":"operation/dk_process/#_3","text":"\u7528\u6237\u540d: donkeycar \u5bc6\u7801: donkeycar IP\u5730\u5740: \u8bf7\u5728\u6bd4\u8d5b\u73b0\u573a\u8054\u7f51\u540e\u901a\u8fc7\u4e0b\u9762\u547d\u4ee4\u83b7\u53d6. hostname -I \u6216\u8005 ifconfig wlan0","title":"\u767b\u5f55\u4fe1\u606f"},{"location":"operation/dk_process/#_4","text":"\u9a74\u8f66\u9879\u76ee\u4f4d\u4e8e /home/donkeycar/projects \u76ee\u5f55 \u8bf7\u5728\u8fdc\u7a0b\u767b\u5f55\u7cfb\u7edf\u540e,\u901a\u8fc7 cd \u547d\u4ee4\u5207\u6362\u81f3\u8be5\u76ee\u5f55,\u5e76\u786e\u8ba4\u5f53\u524d\u4e3a (donkey) \u865a\u62df\u73af\u5883. \u5982\u679c\u5f53\u524d\u4f4d\u4e8e: (base)[donkeycar@donkeycar0X ~]$ #\u6b64\u65f6\u662fconda \u57fa\u7840\u73af\u5883\u9700\u8981\u5207\u6362\u81f3\u9a74\u8f66\u73af\u5883. conda activate donkey \u5982\u679c\u9700\u8981\u9000\u51fa\u865a\u62df\u73af\u5883\u8bf7\u8f93\u5165: conda deactivate donkey","title":"\u9a74\u8f66\u9879\u76ee\u8def\u5f84"},{"location":"operation/dk_process/#_5","text":"\u5728\u7ec8\u7aef\u8f93\u5165: python manage.py drive \u9a74\u8f66\u542f\u52a8\u540e,\u7ec8\u7aef\u4f1a\u88ab\u5360\u7528,\u5982\u679c\u9700\u8981\u7ec8\u6b62\u9a74\u8f66\u8fd0\u884c\u8bf7\u5728\u952e\u76d8\u6309\u4e0b: ctrl + c","title":"\u542f\u52a8\u9a74\u8f66"},{"location":"operation/dk_process/#_6","text":"\u9ed8\u8ba4\u60c5\u51b5\u4e0b,\u9a74\u8f66\u5728\u542f\u52a8\u540e\u4f1a\u901a\u8fc7 tornado \u5b9e\u73b0\u4e00\u4e2a\u7b80\u5355\u7684 web \u9875\u9762,\u8be5\u9875\u9762\u53ef\u7528\u4e8e\u76d1\u63a7\u9a74\u8f66\u884c\u9a76\u72b6\u6001\u53ca\u7f51\u9875\u7aef\u63a7\u5236,\u53ef\u901a\u8fc7\u6d4f\u89c8\u5668\u8bbf\u95ee\u9a74\u8f66IP \u5730\u5740\u53ca\u7aef\u53e3\u6765\u83b7\u53d6. * \u7f51\u9875\u7aef\u6253\u5f00 http://\u9a74\u8f66\u5f53\u524dIP\u5730\u5740:8887 \u7aef\u53e3 \u9ed8\u8ba4\u7aef\u53e3: 8887 \u9a74\u8f66\u5728\u9a7e\u9a76\u8fc7\u7a0b\u4e2d,\u4f1a\u4e0d\u65ad\u901a\u8fc7\u6444\u50cf\u5934\u91c7\u96c6\u56fe\u7247\u4fe1\u606f\u5e76\u6574\u5408\u5f53\u524d\u7684\u89d2\u5ea6\u548c\u6cb9\u95e8\u503c\u5b58\u50a8\u5728 data \u76ee\u5f55. \u5728\u6267\u884c\u7ec8\u7aef\u4e2d\u53ef\u4ee5\u901a\u8fc7\u952e\u76d8\u8f93\u5165: CTRL + C \u7ed3\u675f\u91c7\u96c6.","title":"\u9a74\u8f66\u7f51\u9875\u7aef\u63a7\u5236"},{"location":"operation/dk_process/#_7","text":"\u4e3a\u4e0a\u4f20\u5230Azure \u8fdb\u884c\u4e91\u7aef\u8fdb\u884c\u8bad\u7ec3,\u52a0\u5feb\u8bad\u7ec3\u8fdb\u7a0b. cd /home/pi/projects/mycar/ tar -czvf data.tar.gz data/ ls \u5982\u679c\u6709 data.tar.gz \u7684\u7ea2\u8272\u538b\u7f29\u5305\u5c31\u597d.","title":"\u538b\u7f29\u6253\u5305\u6570\u636e"},{"location":"operation/dk_process/#_8","text":"\u901a\u8fc7 scp \u547d\u4ee4\u62f7\u8d1d scp -P50001 data.tar.gz -i DONKEYCAR_KEY.pem azureuser@AZURE_SERVER_IP:/home/azureuser/mycar/","title":"\u4e0a\u4f20\u4e91\u4e3b\u673a"},{"location":"operation/dk_process/#_9","text":"\u89e3\u538b tar -xf data.tar.gz \u8bf7\u786e\u8ba4\u6570\u636e\u5305\u52a0\u538b\u5230 /home/azureuser/mycar/data \u76ee\u5f55. 2. \u8bad\u7ec3 \u5728\u7ec8\u7aef\u4e2d donkey train --tub data/ --model models/donkeycar01.h5 donkeycar01.h5 \u5c31\u662f\u6a21\u578b\u7684\u540d\u5b57, donkeycar01 \u4e3a\u5f53\u524d\u9a74\u8f66\u7684\u4e3b\u673a\u540d.","title":"\u8bad\u7ec3\u65b9\u6cd5"},{"location":"operation/dk_process/#_10","text":"\u8bad\u7ec3\u5b8c\u6210\u540e\u4f1a\u5728\u9a74\u8f66\u5b9e\u4f8b\u7684 models \u76ee\u5f55\u4e2d\u751f\u6210\u6a21\u578b\u6587\u4ef6. \u7531\u4e8e\u9ed8\u8ba4\u8bad\u7ec3\u51fa\u6765\u7684\u6a21\u578b\u7c7b\u578b\u662f: keras ,\u9700\u8981\u8f6c\u6362\u4e3a tensorflow \u7c7b\u578b,\u518d\u8f6c\u6362\u6210 OpenVINO \u80fd\u8bc6\u522b\u7684\u7c7b\u578b. cd /home/azureuser/projects/traincar/models/ scp -P 50001 azureuser@AZURE_SERVER_IP://home/azureuser/projects/traincar/models/donkeycar01.h5 \u8fd9\u91cc\u7684 -P \u540e\u9762\u586b\u5199\u7684\u670d\u52a1\u5668\u7aef\u53e3\u8bf7\u53c2\u8003\u5bf9\u5e94\u7684\u670d\u52a1\u5668\u7aef\u53e3\u586b\u5199. * 5. \u9a74\u8f66\u81ea\u52a8\u9a7e\u9a76 \u9996\u5148\u8981\u786e\u4fdd\u4f60\u7684\u6a21\u578b\u6587\u4ef6\u653e\u7f6e\u5728\u9a74\u8f66\u7684/home/pi/projects/mycar/models/\u4e0b. \u7136\u540e\u5728\u7ec8\u7aef\u6267\u884c: cd /home/pi/projects/mycar/ python manage.py drive --model models/donkeycar01.h5 \u7f51\u9875\u767b\u9646\u5230\u63a7\u5236\u7ec8\u7aef: http://\u9a74\u8f66\u5f53\u524dIP\u5730\u5740:8887/ \u5148\u70b9\u51fb\u9875\u9762\u4e0b\u65b9\u7684: start vehicle \u6309\u94ae \u7136\u540e\u5728 mode & pilot \u9009\u62e9 local pilot \u5c0f\u8f66\u5c31\u5f00\u59cb\u81ea\u884c\u9a7e\u9a76\u4e86. \u9700\u8981\u7ec8\u6b62\u8bf7\u5728\u7ec8\u7aef\u4e0a\u6309\u4e0b Ctrl + C","title":"\u8f6c\u6362\u6a21\u578b"},{"location":"operation/drive_tips/","text":"\u6280\u5de7\u65b9\u6848 \u5176\u4e2d\u7684\u5f88\u591a\u6280\u5de7\u662f\u5728\u4e0d\u65ad\u7684\u8bd5\u9519\u4e2d\u5c1d\u8bd5\u51fa\u6765\u7684.\u5e0c\u671b\u8fd9\u4e9b\u6280\u5de7\u80fd\u591f\u5e2e\u52a9\u5404\u4f4d\u5feb\u901f\u8bad\u7ec3\u51fa\u51c6\u786e\u7684\u6a21\u578b. \u91c7\u96c6\u6570\u636e\u6280\u5de7 \u91c7\u96c6\u6570\u636e\u7684\u65f6\u5019,\u6570\u636e\u7684\u9897\u7c92\u5ea6\u5982\u6cb9\u95e8,\u89d2\u5ea6(throttle, angle) \u8fd9\u4e24\u4e2a\u53c2\u6570\u4f1a\u5bf9\u672a\u6765\u751f\u6210\u7684\u6a21\u578b\u4ea7\u751f\u5f88\u5927\u7684\u5f71\u54cd.\u56e0\u6b64\u6570\u636e\u91c7\u96c6\u7684\u65f6\u5019,\u5982\u679c\u4f7f\u7528RC \u67aa\u63a7\u7684\u6570\u636e\u66f2\u7ebf\u8981\u597d\u4e8e\u4f7f\u7528 PS3/XBOX \u624b\u67c4, \u800c\u4f7f\u7528\u624b\u67c4\u7684\u6570\u636e\u4f1a\u8981\u6bd4\u76f4\u63a5\u4f7f\u7528\u7f51\u9875\u63a7\u5236\u7aef\u7684\u6570\u636e\u66f2\u7ebf\u597d. \u91c7\u96c6\u6570\u636e\u65f6, \u5728\u7f51\u9875\u7aef\u53ef\u4ee5\u8bbe\u7f6e\u9650\u5236\u6700\u5927\u901f\u5ea6,\u521d\u7ea7\u7528\u6237\u6700\u597d\u5c06\u6cb9\u95e8\u9650\u5236\u5728 30~40% \u4e4b\u95f4,\u64cd\u4f5c\u4f1a\u66f4\u52a0\u5e73\u7a33,\u968f\u7740\u719f\u7ec3\u5ea6\u7684\u63d0\u9ad8,\u9010\u6b65\u8c03\u6574\u6cb9\u95e8\u7684\u5927\u5c0f,\u76f4\u5230\u5168\u6cb9\u95e8\u6f02\u79fb\u8fc7\u5f2f. \u5728\u6a21\u62df\u5668\u4e0a\u9a7e\u9a76\u7684\u65f6\u5019, \u5728\u8fdb\u5165\u5f2f\u9053\u65f6,\u677e\u5f00\u6cb9\u95e8,\u8f7b\u70b9\u5239\u8f66\u5e76\u8f6c\u5411\u53ef\u4ee5\u5b9e\u73b0\u6f02\u79fb\u8fc7\u5f2f\u7684\u6548\u679c,\u524d\u63d0\u662f\u6cb9\u95e8\u9650\u5236\u4e3a 0,\u901f\u5ea6\u4e3a\u9ed8\u8ba4\u6700\u5927\u901f\u5ea6\u65f6. \u6570\u636e\u5904\u7406\u6280\u5de7 \u5728\u6570\u636e\u91c7\u96c6\u5b8c\u6210\u540e,\u53ef\u4ee5\u901a\u8fc7\u5728\u547d\u4ee4\u884c\u4e2d\u8f93\u5165: donkey ui \u6765\u542f\u52a8 donkey ui \u7684\u56fe\u5f62\u5316\u754c\u9762\u8fdb\u884c\u6570\u636e\u7684\u7b5b\u9009, \u53c2\u6570\u7684\u9009\u62e9\u548c\u6a21\u578b\u7c7b\u578b\u9009\u62e9, \u5e76\u4e14\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5254\u9664\u4e0d\u597d\u7684\u8bb0\u5f55\u4fe1\u606f,\u4ece\u800c\u4f7f\u6574\u4e2a\u6570\u636e\u96c6\u7684\u6570\u636e\u4e00\u81f4\u6027\u66f4\u597d,\u8bad\u7ec3\u7684\u6a21\u578b\u4e5f\u4f1a\u66f4\u52a0\u7684\u7a33\u5b9a. Donkey ui\u64cd\u4f5c\u6b65\u9aa4 TBD RC \u64cd\u4f5c\u6280\u5de7 RC \u67aa\u63a7\u7684\u6273\u673a\u548c\u8f6c\u8f6e\u5206\u522b\u5bf9\u5e94\u6cb9\u95e8\u548c\u8f6c\u5411.(throttle \u548c angle) \u5728\u4f7f\u7528 RC \u67aa\u63a7\u64cd\u4f5c\u9a74\u8f66\u65f6,\u8bf7\u6ce8\u610f\u4e0d\u8981\u731b\u7684\u89e6\u53d1\u6273\u673a,\u6216\u8005\u662f\u731b\u6253\u8f6c\u5411, \u5c3d\u91cf\u8bf7\u6253\u65b9\u5411,\u907f\u514d \u5f39\u8f6e\u513f \u60c5\u51b5\u51fa\u73b0. \u5f39\u8f6e\u513f \u610f\u601d\u662f\u626d\u8f6c\u65b9\u5411\u8f6e\u5230\u67d0\u4e2a\u4f4d\u7f6e,\u987a\u624b\u677e\u5f00\u4f7f\u5176\u4ee5\u539f\u6709\u7684\u56de\u5f39\u529b\u53cd\u5f39\u56de\u539f\u4f4d,\u8fd9\u6837\u4f1a\u4ea7\u751f\u6570\u636e\u6ce2\u52a8\u5c16\u5cf0, \u4e0d\u5229\u4e8e\u6570\u636e\u6a21\u578b\u7684\u8bad\u7ec3.","title":"\u9a7e\u9a76\u6280\u5de7"},{"location":"operation/drive_tips/#_1","text":"\u5176\u4e2d\u7684\u5f88\u591a\u6280\u5de7\u662f\u5728\u4e0d\u65ad\u7684\u8bd5\u9519\u4e2d\u5c1d\u8bd5\u51fa\u6765\u7684.\u5e0c\u671b\u8fd9\u4e9b\u6280\u5de7\u80fd\u591f\u5e2e\u52a9\u5404\u4f4d\u5feb\u901f\u8bad\u7ec3\u51fa\u51c6\u786e\u7684\u6a21\u578b.","title":"\u6280\u5de7\u65b9\u6848"},{"location":"operation/drive_tips/#_2","text":"\u91c7\u96c6\u6570\u636e\u7684\u65f6\u5019,\u6570\u636e\u7684\u9897\u7c92\u5ea6\u5982\u6cb9\u95e8,\u89d2\u5ea6(throttle, angle) \u8fd9\u4e24\u4e2a\u53c2\u6570\u4f1a\u5bf9\u672a\u6765\u751f\u6210\u7684\u6a21\u578b\u4ea7\u751f\u5f88\u5927\u7684\u5f71\u54cd.\u56e0\u6b64\u6570\u636e\u91c7\u96c6\u7684\u65f6\u5019,\u5982\u679c\u4f7f\u7528RC \u67aa\u63a7\u7684\u6570\u636e\u66f2\u7ebf\u8981\u597d\u4e8e\u4f7f\u7528 PS3/XBOX \u624b\u67c4, \u800c\u4f7f\u7528\u624b\u67c4\u7684\u6570\u636e\u4f1a\u8981\u6bd4\u76f4\u63a5\u4f7f\u7528\u7f51\u9875\u63a7\u5236\u7aef\u7684\u6570\u636e\u66f2\u7ebf\u597d. \u91c7\u96c6\u6570\u636e\u65f6, \u5728\u7f51\u9875\u7aef\u53ef\u4ee5\u8bbe\u7f6e\u9650\u5236\u6700\u5927\u901f\u5ea6,\u521d\u7ea7\u7528\u6237\u6700\u597d\u5c06\u6cb9\u95e8\u9650\u5236\u5728 30~40% \u4e4b\u95f4,\u64cd\u4f5c\u4f1a\u66f4\u52a0\u5e73\u7a33,\u968f\u7740\u719f\u7ec3\u5ea6\u7684\u63d0\u9ad8,\u9010\u6b65\u8c03\u6574\u6cb9\u95e8\u7684\u5927\u5c0f,\u76f4\u5230\u5168\u6cb9\u95e8\u6f02\u79fb\u8fc7\u5f2f. \u5728\u6a21\u62df\u5668\u4e0a\u9a7e\u9a76\u7684\u65f6\u5019, \u5728\u8fdb\u5165\u5f2f\u9053\u65f6,\u677e\u5f00\u6cb9\u95e8,\u8f7b\u70b9\u5239\u8f66\u5e76\u8f6c\u5411\u53ef\u4ee5\u5b9e\u73b0\u6f02\u79fb\u8fc7\u5f2f\u7684\u6548\u679c,\u524d\u63d0\u662f\u6cb9\u95e8\u9650\u5236\u4e3a 0,\u901f\u5ea6\u4e3a\u9ed8\u8ba4\u6700\u5927\u901f\u5ea6\u65f6.","title":"\u91c7\u96c6\u6570\u636e\u6280\u5de7"},{"location":"operation/drive_tips/#_3","text":"\u5728\u6570\u636e\u91c7\u96c6\u5b8c\u6210\u540e,\u53ef\u4ee5\u901a\u8fc7\u5728\u547d\u4ee4\u884c\u4e2d\u8f93\u5165: donkey ui \u6765\u542f\u52a8 donkey ui \u7684\u56fe\u5f62\u5316\u754c\u9762\u8fdb\u884c\u6570\u636e\u7684\u7b5b\u9009, \u53c2\u6570\u7684\u9009\u62e9\u548c\u6a21\u578b\u7c7b\u578b\u9009\u62e9, \u5e76\u4e14\u8fd8\u53ef\u4ee5\u901a\u8fc7\u5254\u9664\u4e0d\u597d\u7684\u8bb0\u5f55\u4fe1\u606f,\u4ece\u800c\u4f7f\u6574\u4e2a\u6570\u636e\u96c6\u7684\u6570\u636e\u4e00\u81f4\u6027\u66f4\u597d,\u8bad\u7ec3\u7684\u6a21\u578b\u4e5f\u4f1a\u66f4\u52a0\u7684\u7a33\u5b9a.","title":"\u6570\u636e\u5904\u7406\u6280\u5de7"},{"location":"operation/drive_tips/#donkey-ui","text":"TBD","title":"Donkey ui\u64cd\u4f5c\u6b65\u9aa4"},{"location":"operation/drive_tips/#rc","text":"RC \u67aa\u63a7\u7684\u6273\u673a\u548c\u8f6c\u8f6e\u5206\u522b\u5bf9\u5e94\u6cb9\u95e8\u548c\u8f6c\u5411.(throttle \u548c angle) \u5728\u4f7f\u7528 RC \u67aa\u63a7\u64cd\u4f5c\u9a74\u8f66\u65f6,\u8bf7\u6ce8\u610f\u4e0d\u8981\u731b\u7684\u89e6\u53d1\u6273\u673a,\u6216\u8005\u662f\u731b\u6253\u8f6c\u5411, \u5c3d\u91cf\u8bf7\u6253\u65b9\u5411,\u907f\u514d \u5f39\u8f6e\u513f \u60c5\u51b5\u51fa\u73b0. \u5f39\u8f6e\u513f \u610f\u601d\u662f\u626d\u8f6c\u65b9\u5411\u8f6e\u5230\u67d0\u4e2a\u4f4d\u7f6e,\u987a\u624b\u677e\u5f00\u4f7f\u5176\u4ee5\u539f\u6709\u7684\u56de\u5f39\u529b\u53cd\u5f39\u56de\u539f\u4f4d,\u8fd9\u6837\u4f1a\u4ea7\u751f\u6570\u636e\u6ce2\u52a8\u5c16\u5cf0, \u4e0d\u5229\u4e8e\u6570\u636e\u6a21\u578b\u7684\u8bad\u7ec3.","title":"RC \u64cd\u4f5c\u6280\u5de7"},{"location":"parts/about_parts/","text":"\u4ec0\u4e48\u662f Part A part is a Python class that wraps a functional component of a vehicle. \u4e00\u4e2a part \u5c31\u662f\u4e00\u4e2a python \u7684\u7c7b, \u53ef\u4ee5\u6dfb\u52a0\u4e00\u4e2a\u529f\u80fd\u5230\u6211\u4eec\u7684\u9a74\u8f66\u4e0a. \u8fd9\u4e9b\u5305\u62ec: Sensors - \u6444\u50cf\u5934, \u96f7\u8fbe, \u901f\u5ea6\u8ba1, GPS Actuators - \u7535\u673a\u63a7\u5236\u7c7b Pilots - \u9053\u8def\u68c0\u6d4b, \u514b\u9686\u6a21\u578b\u7b49\u7b49\u529f\u80fd. Controllers - \u57fa\u4e8e\u7f51\u9875\u6216\u8005\u84dd\u7259. Stores - Tub, \u6216\u8005\u5b58\u50a8\u6570\u636e\u7684\u65b9\u6cd5 \u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\u663e\u793a\u5982\u4f55\u4f7f\u7528 PiCamera part \u53bb\u5728\u6bcf\u4e2a\u9a7e\u9a76\u7684\u5faa\u73af\u4e2d\u53d1\u5e03\u4e00\u4e2a\u56fe\u7247\u5230\"cam/img\" \u901a\u9053. V = dk.Vehicle() # \u521b\u5efa\u5e76\u521d\u59cb\u5316camera part cam = PiCamera() #\u6dfb\u52a0\u6444\u50cf\u5934\u5230vehicle. V.add(cam, outputs=['cam/img']) V.start() \u5256\u6790\u4e00\u4e2a part \u6240\u6709\u90e8\u4ef6(part) \u5171\u4eab\u540c\u4e00\u4e2a\u5171\u540c\u7684\u7ed3\u6784,\u56e0\u6b64\u4ed6\u4eec\u90fd\u53ef\u4ee5\u7531\u8f66\u8f86\u7684\u5b9e\u4f8b\u9a71\u52a8\u5728\u6574\u4e2a\u7a0b\u5e8f\u8fd0\u884c\u72b6\u6001\u4e2d\u4e0d\u65ad\u8fd0\u884c\u548c\u66f4\u65b0\u6570\u636e. \u6240\u6709\u7684\u90e8\u4ef6\u90fd\u9700\u8981\u6709\u4e00\u4e2a\"run\" \u6216\u8005\" run_threaded\" \u529f\u80fd,\u5b83\u6709\u65f6\u5019\u4e5f\u9700\u8981 inputs=['\u5355\u5f15\u53f7'],'\u9017\u53f7\u5206\u5272'] \u8fd9\u79cd\u8f93\u5165\u7684\u683c\u5f0f,\u4e5f\u4f1a\u5728\u8c03\u7528\u7684\u65f6\u5019\u751f\u6210\u7c7b\u4f3c outputs=['\u5173\u952e\u5b57', '\u9017\u53f7\u5206\u5272'] \u7684\u8f93\u51fa\u6570\u636e. \u5982\u679c\u8f66\u7684\u90e8\u4ef6\u4f1a\u6293\u53d6\u90e8\u5206\u786c\u4ef6\u8d44\u6e90\u4fe1\u606f, \u7c7b\u4f3c\u6444\u50cf\u5934\u548c\u4e32\u53e3\u7b49\u8bbe\u5907, \u5728\u9a74\u8f66\u505c\u6b62\u7684\u65f6\u5019,\u90a3\u4e48\u5b83\u5e94\u8be5\u5305\u542b\u4e00\u4e2a shutdown \u7684\u65b9\u6cd5\u6765\u91ca\u653e\u8d44\u6e90. \u4e0b\u9762\u4e3e\u4e2a\u4f8b\u5b50: \u4e00\u4e2a part \u63a5\u53d7\u4e00\u4e2a\u6570\u5b57,\u7136\u540e\u4e0e\u4e00\u4e2a\u968f\u673a\u6570\u5b57\u5b8c\u6210\u4e58\u6cd5\u8fd0\u7b97\u5e76\u8fd4\u56de\u7ed3\u679c. import random class RandPercent: def run(self, x): return x * random.random() \u628a\u8fd9\u4e2a\u7c7b\u6dfb\u52a0\u5230 donkeycar \u7684 vehicle: V = dk.Vehicle() # initialize the channel value V.mem['const'] = 4 # add the part to read and write to the same channel. V.add(RandPercent, inputs=['const'], outputs=['const']) V.start(max_loops=5) \u90e8\u4ef6\u7ebf\u7a0b\u5316 \u5982\u679c\u60f3\u8981\u4fdd\u8bc1\u9a74\u8f66\u8fd0\u884c\u7684\u6027\u80fd\u5219\u9700\u8981\u4fdd\u8bc1 drive loop \u5fc5\u987b\u4fdd\u8bc1\u5728 10-30 \u6b21/\u79d2,(\u68c0\u6d4b\u6570\u636e\u6765\u81ea: DRIVE_LOOP_HZ , \u8fd9\u4e2a\u914d\u7f6e\u6765\u81ea\u4f60\u7684\u914d\u7f6e\u6587\u4ef6(myconfig.py),\u9ed8\u8ba4\u503c\u662f 20hz ) \u56e0\u6b64, \u4e00\u4e9b\u6162\u901f\u7684\u90e8\u4ef6\u5e94\u8be5\u7ebf\u7a0b\u5316(threaded)\u4ece\u800c\u907f\u514d\u5ef6\u957f\u6bcf\u4e2a drive loop \u7684\u65f6\u95f4. \u4e00\u4e2a\u7ebf\u7a0b\u5316\u7684\u90e8\u4ef6\u9700\u8981\u53bb\u5b9a\u4e49\u65b9\u6cd5\u53bb\u8fd0\u884c\u5728\u72ec\u7acb\u7684\u7ebf\u7a0b\u4e0a, \u5e76\u4e14\u65b9\u6cd5\u5728\u88ab\u8c03\u7528\u7684\u65f6\u5019\u80fd\u591f\u975e\u5e38\u5feb\u7684\u8fd4\u56de\u5f53\u524d\u6700\u65b0\u7684\u6570\u636e. \u5f53\u4f60\u6dfb\u52a0\u4e00\u4e2a\u90e8\u4ef6\u5230\u8f66\u8f86, \u5c31\u662f V.add \u4e4b\u524d, \u521b\u5efa\u7684\u90e8\u4ef6\u5982\u679c\u6dfb\u52a0\u4e86 theaded = True , \u90a3\u4e48\u9a74\u8f66\u4e3b\u7a0b\u5e8f\u4f1a\u8c03\u7528\u90e8\u4ef6\u7684 run_threaded \u65b9\u6cd5\u53bb\u66ff\u4ee3 run \u65b9\u6cd5,\u76ee\u524d\u4f60\u53ef\u4ee5\u53c2\u8003\u4e0b\u9762\u7684\u4f8b\u5b50\u6765\u5b9e\u73b0. V.add(RandPercent, inputs=['const'], outputs=['const'], threaded=True) \u4e00\u65e6\u4f60\u6709\u4e00\u4e2a\"run_threaded\" \u65b9\u6cd5, donkey \u5c31\u4f1a\u81ea\u52a8\u53bb\u5bfb\u627e\u4e00\u4e2a\"update\"\u65b9\u6cd5\u5e76\u4e14\u5728\u5b83\u81ea\u5df1\u7684\u7ebf\u7a0b\u4e2d\u8fd0\u884c\u5b83, \u4e0b\u9762\u7684\u4f8b\u5b50\u662f\u5982\u4f55\u5c06 RandPercent \u90e8\u4ef6\u7ebf\u7a0b\u5316,\u5982\u679c\u8fd9\u4e2a\u90e8\u4ef6\u9700\u8981\u8fd0\u884c\u4e00\u6bb5\u65f6\u95f4\u624d\u80fd\u5b8c\u6210\u7684\u8bdd,\u610f\u601d\u5c31\u662f\u5982\u679c\u4f60\u7684\u90e8\u4ef6\u8017\u65f6\u957f,\u5c31\u7ebf\u7a0b\u5316,\u8fd9\u6837\u4e0d\u4f1a\u5f71\u54cd\u6574\u4e2a\u5927\u5faa\u73af. import random import time class RandPercent: self.in = 0.0 self.out = 0.0 def run(self, x): return x * random.random() time.sleep(1) def update(self): # the function run in its own thread while True: self.out = self.run(self.in) def run_threaded(self, x): self.in = x return self.out part.run : \u65b9\u6cd5\u662f\u8fd0\u884c\u8fd9\u4e2a\u90e8\u4ef6. part.run_threaded : \u5982\u679c\u90e8\u4ef6\u7ebf\u7a0b\u5316,\u90a3\u4e48\u9a74\u8f66\u4e3b\u5faa\u73af\u4f1a\u4ee5\u7ebf\u7a0b\u65b9\u5f0f\u8fd0\u884c\u8fd9\u4e2a\u90e8\u4ef6. part.update : \u7ebf\u7a0b\u66f4\u65b0\u7684\u65b9\u6cd5 part.shutdown \u5173\u95ed\u8fdb\u7a0b","title":"\u5173\u4e8e\u90e8\u4ef6"},{"location":"parts/about_parts/#part","text":"A part is a Python class that wraps a functional component of a vehicle. \u4e00\u4e2a part \u5c31\u662f\u4e00\u4e2a python \u7684\u7c7b, \u53ef\u4ee5\u6dfb\u52a0\u4e00\u4e2a\u529f\u80fd\u5230\u6211\u4eec\u7684\u9a74\u8f66\u4e0a. \u8fd9\u4e9b\u5305\u62ec: Sensors - \u6444\u50cf\u5934, \u96f7\u8fbe, \u901f\u5ea6\u8ba1, GPS Actuators - \u7535\u673a\u63a7\u5236\u7c7b Pilots - \u9053\u8def\u68c0\u6d4b, \u514b\u9686\u6a21\u578b\u7b49\u7b49\u529f\u80fd. Controllers - \u57fa\u4e8e\u7f51\u9875\u6216\u8005\u84dd\u7259. Stores - Tub, \u6216\u8005\u5b58\u50a8\u6570\u636e\u7684\u65b9\u6cd5 \u4e0b\u9762\u662f\u4e00\u4e2a\u793a\u4f8b\u663e\u793a\u5982\u4f55\u4f7f\u7528 PiCamera part \u53bb\u5728\u6bcf\u4e2a\u9a7e\u9a76\u7684\u5faa\u73af\u4e2d\u53d1\u5e03\u4e00\u4e2a\u56fe\u7247\u5230\"cam/img\" \u901a\u9053. V = dk.Vehicle() # \u521b\u5efa\u5e76\u521d\u59cb\u5316camera part cam = PiCamera() #\u6dfb\u52a0\u6444\u50cf\u5934\u5230vehicle. V.add(cam, outputs=['cam/img']) V.start()","title":"\u4ec0\u4e48\u662f Part"},{"location":"parts/about_parts/#part_1","text":"\u6240\u6709\u90e8\u4ef6(part) \u5171\u4eab\u540c\u4e00\u4e2a\u5171\u540c\u7684\u7ed3\u6784,\u56e0\u6b64\u4ed6\u4eec\u90fd\u53ef\u4ee5\u7531\u8f66\u8f86\u7684\u5b9e\u4f8b\u9a71\u52a8\u5728\u6574\u4e2a\u7a0b\u5e8f\u8fd0\u884c\u72b6\u6001\u4e2d\u4e0d\u65ad\u8fd0\u884c\u548c\u66f4\u65b0\u6570\u636e. \u6240\u6709\u7684\u90e8\u4ef6\u90fd\u9700\u8981\u6709\u4e00\u4e2a\"run\" \u6216\u8005\" run_threaded\" \u529f\u80fd,\u5b83\u6709\u65f6\u5019\u4e5f\u9700\u8981 inputs=['\u5355\u5f15\u53f7'],'\u9017\u53f7\u5206\u5272'] \u8fd9\u79cd\u8f93\u5165\u7684\u683c\u5f0f,\u4e5f\u4f1a\u5728\u8c03\u7528\u7684\u65f6\u5019\u751f\u6210\u7c7b\u4f3c outputs=['\u5173\u952e\u5b57', '\u9017\u53f7\u5206\u5272'] \u7684\u8f93\u51fa\u6570\u636e. \u5982\u679c\u8f66\u7684\u90e8\u4ef6\u4f1a\u6293\u53d6\u90e8\u5206\u786c\u4ef6\u8d44\u6e90\u4fe1\u606f, \u7c7b\u4f3c\u6444\u50cf\u5934\u548c\u4e32\u53e3\u7b49\u8bbe\u5907, \u5728\u9a74\u8f66\u505c\u6b62\u7684\u65f6\u5019,\u90a3\u4e48\u5b83\u5e94\u8be5\u5305\u542b\u4e00\u4e2a shutdown \u7684\u65b9\u6cd5\u6765\u91ca\u653e\u8d44\u6e90. \u4e0b\u9762\u4e3e\u4e2a\u4f8b\u5b50: \u4e00\u4e2a part \u63a5\u53d7\u4e00\u4e2a\u6570\u5b57,\u7136\u540e\u4e0e\u4e00\u4e2a\u968f\u673a\u6570\u5b57\u5b8c\u6210\u4e58\u6cd5\u8fd0\u7b97\u5e76\u8fd4\u56de\u7ed3\u679c. import random class RandPercent: def run(self, x): return x * random.random() \u628a\u8fd9\u4e2a\u7c7b\u6dfb\u52a0\u5230 donkeycar \u7684 vehicle: V = dk.Vehicle() # initialize the channel value V.mem['const'] = 4 # add the part to read and write to the same channel. V.add(RandPercent, inputs=['const'], outputs=['const']) V.start(max_loops=5)","title":"\u5256\u6790\u4e00\u4e2a part"},{"location":"parts/about_parts/#_1","text":"\u5982\u679c\u60f3\u8981\u4fdd\u8bc1\u9a74\u8f66\u8fd0\u884c\u7684\u6027\u80fd\u5219\u9700\u8981\u4fdd\u8bc1 drive loop \u5fc5\u987b\u4fdd\u8bc1\u5728 10-30 \u6b21/\u79d2,(\u68c0\u6d4b\u6570\u636e\u6765\u81ea: DRIVE_LOOP_HZ , \u8fd9\u4e2a\u914d\u7f6e\u6765\u81ea\u4f60\u7684\u914d\u7f6e\u6587\u4ef6(myconfig.py),\u9ed8\u8ba4\u503c\u662f 20hz ) \u56e0\u6b64, \u4e00\u4e9b\u6162\u901f\u7684\u90e8\u4ef6\u5e94\u8be5\u7ebf\u7a0b\u5316(threaded)\u4ece\u800c\u907f\u514d\u5ef6\u957f\u6bcf\u4e2a drive loop \u7684\u65f6\u95f4. \u4e00\u4e2a\u7ebf\u7a0b\u5316\u7684\u90e8\u4ef6\u9700\u8981\u53bb\u5b9a\u4e49\u65b9\u6cd5\u53bb\u8fd0\u884c\u5728\u72ec\u7acb\u7684\u7ebf\u7a0b\u4e0a, \u5e76\u4e14\u65b9\u6cd5\u5728\u88ab\u8c03\u7528\u7684\u65f6\u5019\u80fd\u591f\u975e\u5e38\u5feb\u7684\u8fd4\u56de\u5f53\u524d\u6700\u65b0\u7684\u6570\u636e. \u5f53\u4f60\u6dfb\u52a0\u4e00\u4e2a\u90e8\u4ef6\u5230\u8f66\u8f86, \u5c31\u662f V.add \u4e4b\u524d, \u521b\u5efa\u7684\u90e8\u4ef6\u5982\u679c\u6dfb\u52a0\u4e86 theaded = True , \u90a3\u4e48\u9a74\u8f66\u4e3b\u7a0b\u5e8f\u4f1a\u8c03\u7528\u90e8\u4ef6\u7684 run_threaded \u65b9\u6cd5\u53bb\u66ff\u4ee3 run \u65b9\u6cd5,\u76ee\u524d\u4f60\u53ef\u4ee5\u53c2\u8003\u4e0b\u9762\u7684\u4f8b\u5b50\u6765\u5b9e\u73b0. V.add(RandPercent, inputs=['const'], outputs=['const'], threaded=True) \u4e00\u65e6\u4f60\u6709\u4e00\u4e2a\"run_threaded\" \u65b9\u6cd5, donkey \u5c31\u4f1a\u81ea\u52a8\u53bb\u5bfb\u627e\u4e00\u4e2a\"update\"\u65b9\u6cd5\u5e76\u4e14\u5728\u5b83\u81ea\u5df1\u7684\u7ebf\u7a0b\u4e2d\u8fd0\u884c\u5b83, \u4e0b\u9762\u7684\u4f8b\u5b50\u662f\u5982\u4f55\u5c06 RandPercent \u90e8\u4ef6\u7ebf\u7a0b\u5316,\u5982\u679c\u8fd9\u4e2a\u90e8\u4ef6\u9700\u8981\u8fd0\u884c\u4e00\u6bb5\u65f6\u95f4\u624d\u80fd\u5b8c\u6210\u7684\u8bdd,\u610f\u601d\u5c31\u662f\u5982\u679c\u4f60\u7684\u90e8\u4ef6\u8017\u65f6\u957f,\u5c31\u7ebf\u7a0b\u5316,\u8fd9\u6837\u4e0d\u4f1a\u5f71\u54cd\u6574\u4e2a\u5927\u5faa\u73af. import random import time class RandPercent: self.in = 0.0 self.out = 0.0 def run(self, x): return x * random.random() time.sleep(1) def update(self): # the function run in its own thread while True: self.out = self.run(self.in) def run_threaded(self, x): self.in = x return self.out part.run : \u65b9\u6cd5\u662f\u8fd0\u884c\u8fd9\u4e2a\u90e8\u4ef6. part.run_threaded : \u5982\u679c\u90e8\u4ef6\u7ebf\u7a0b\u5316,\u90a3\u4e48\u9a74\u8f66\u4e3b\u5faa\u73af\u4f1a\u4ee5\u7ebf\u7a0b\u65b9\u5f0f\u8fd0\u884c\u8fd9\u4e2a\u90e8\u4ef6. part.update : \u7ebf\u7a0b\u66f4\u65b0\u7684\u65b9\u6cd5 part.shutdown \u5173\u95ed\u8fdb\u7a0b","title":"\u90e8\u4ef6\u7ebf\u7a0b\u5316"},{"location":"parts/actuators/","text":"Actuators A car needs a way to to move forward and backward and to turn left and right. We commonly call devices that produce a physical movement in the robot 'actuators'. Common actuators are DC motors, Servo motors, continuous servo motors and stepper motors. There are many, many different ways that these actuators can be combined to propel and turn a robot. Donkeycar supports two common configurations that can be implemented with various actuators: Car-like vehicles steer by angling the front wheels left or right and move by turning the drive wheels forward or reverse. Common RC cars fall in this category. Differential drive vehicles have two independently controlled drive wheels to provide both movement and steering. For instance a differential drive car can be driven straight forward by turning the two drive wheels forward at the same speed. In order to turn, one motor can be driven faster than the other and the car will turn an arc in the direction of the slower motor. Actuators take control signals from the Donkeycar to control their actions. There are several options for generating these control signals. - PCA9685 Servo controller board - RPi/Jetson 40 pin GPIO header - see Generating PWM from the Jetson Nano for how to enable PWM output from the Jetson Nano 40 pin GPIO header. - Arduino Below we will describe the supported actuator setups and software configuration of their control signals. Standard RC with ESC and Steering Servo. A standard RC car is equipped with a steering servo for steering the front wheels and an ESC (Electronic Speed Controller) to control the speed of the DC motor driving the wheels. Both the steering servo and the ESC take a PWM (Pulse Width Modulation) control signal. A PWM signal is simply a square wave pulse of a certain duration and frequency. In the case of the steering servo the PWM signal determines the position of the servo's arm, which is generally between 0 degrees (full right) and 180 degrees (full left). In the case of the ESC the PWM signal determines the direction and speed of the drive motor, from full reverse, through stopped, to full forward. Standard RC servo pulses range from 1 millisecond (full reverse for ESC, fully left for servo) to 2 milliseconds (full forward for ESC, full right for servo) with 1.5 milliseconds being neutral (stopped for ESC, straight for servo). These pulses are typically sent at 50 hertz (one duty cycle every 20 milliseconds). One duty cycle includes a period where the signal is brought high followed by a period where the signal is brought low. This means that, using the standard 50hz frequency, a 1 millisecond pulse (1 ms high followed by 19 ms low) represents a 5% duty cycle and a 2 millisecond pulse represents a 10% duty cycle. The most important part is the length of the pulse; it must be in the range of 1 to 2 milliseconds. So this means that if a different frequency is used, then the duty cycle must be adjusted in order to get the 1ms to 2ms pulse. For instance, if a 60hz frequency is used, then a 1 ms pulse requires a duty cycle of 0.05 * 60 / 50 = 0.06 (6%) duty cycle We default the frequency of our PCA9685 to 60 hz, so pulses in config are generally based on 60hz frequency and 12 bit values. We use 12 bit values because the PCA9685 has 12 bit resolution. So a 1 ms pulse is 0.06 * 4096 ~= 246, a neutral pulse of 0.09 duty cycle is 0.09 * 4096 ~= 367 and full forward pulse of 0.12 duty cycles is 0.12 * 4096 ~= 492 These are generalizations that are useful for understanding the underlying api call arguments and the values that are generating when calibrating. The final choice of duty-cycle/pulse length depends on your hardware and perhaps your strategy (you may not want to go too fast, and so you may choose is low max throttle pwm) Generating PWM pulses with a PCA9685 Servo controller The hardware connection of the PCA9685 I2C servo driver board is described fully in the overall setup instructions here The PCA9685 Servo controller is connected the RaspberryPi or Jetson Nano via the I2C pins on the 40 Pin bus, then the 3 pin cables from the ESC and Steering Servo are connected to the PCA9685, generally to channel 0 and channel 1 respectively. See Step 4: Connect Servo Shield . Connection of a PCA9685 to a Jetson Nano is the same. Configuration Use DRIVE_TRAIN_TYPE = \"PWM_STEERING_THROTTLE\" in myconfig.py Set the pin specifiers for PCA9685 in the # PWM_STEERING_THROTTLE section of myconfig.py. For example: PWM_STEERING_PIN = \"PCA9685.1:40.0\" # PCA9685, I2C bus 1, address 0x40, channel 0 PWM_THROTTLE_PIN = \"PCA9685.1:40.1\" # PCA9685, I2C bus 1, address 0x40, channel 1 See pins for a detailed discussion of pin providers and pin specifiers. Generating PWM pulses from the 40 pin GPIO header Here the PWM signal is generated from the 40 pin GPIO header. The data pin on the 3-pin ESC and Servo connectors are connected to a PWM pin on the GPIO. The ground pins on the 3-pin connectors are connected to a common ground. The 5V pins on the 3-pin connectors are connected to the 5V pins on the GPIO: the 3-pin connector from the ESC will generally provide 5V that can then be used to power the Servo. Configuration Use DRIVE_TRAIN_TYPE = \"PWM_STEERING_THROTTLE\" in myconfig.py Set the pin specifiers for GPIO in the # PWM_STEERING_THROTTLE section. Note that each pin has both a BOARD mode and a BCM (Broadcom) mode identifier. You can use either mode, but all pins must use the same mode. For example: PWM_STEERING_PIN = \"RPI_GPIO.BOARD.33\" # GPIO board mode pin-33 == BCM mode pin-13 PWM_THROTTLE_PIN = \"RPI_GPIO.BOARD.12\" # GPIO board mode pin-12 == BCM mode pin-18 See pins for a detailed discussion of pin providers and pin specifiers. Direct control with the RaspberryPi GPIO pins. Please follow the instructions here Control with the Robo HAT MM1 board. Please follow the instructions here Arduino Arduino can be used in the following fashion to generate PWM signals to control the steering and throttle. For now the Arduino mode is only tested on the Latte Panda Delta (LP-D) board. However it should be straightforward to use it with Raspberry Pi / Jetson Nano (instead of PCA 9685). Refer to the below block diagram to understand where things fits in. Arduino board should be running the standard firmata sketch (This sketch comes by default when you download the arduino tool). Load the standard firmata sketch (from Examples > Firmata > StandardFirmata ) onto the Arduino. Further pymata_aio_ python package needs to be installed on the car computer via pip3 install pymata_aio . As shown in the block-diagram above LattePanda combines both the x86 CPU and the Connected Arduino into a single board. The following diagram shows how to connect the Arduino pins to steering servo and ESC. Note that the power for the servo is provided by the ESC battery elemininator circuit (BEC) which most ESC's provide. This is done to avoid supplying the entire servo power from Arduino's 5v. In large RC cars the servo can drag up to 2 amps, which lead to a destruction of the Arduino. Calibration Note that the calibration procedure/values are slightly different for the Arduino (than PCA9685). Note that 90 is the usual midpoint (i.e. 1.5 ms pulse width at 50 Hz), so it is recommended to start with 90 and adjust +/- 5 until you figure the desired range for steering / throttle. (env1) jithu@jithu-lp:~/master/pred_mt/lp/001/donkey$ donkey calibrate --arduino --channel 6 using donkey v2.6.0t ... pymata_aio Version 2.33 Copyright (c) 2015-2018 Alan Yorinks All rights reserved. Using COM Port:/dev/ttyACM0 Initializing Arduino - Please wait... Arduino Firmware ID: 2.5 StandardFirmata.ino Auto-discovery complete. Found 30 Digital Pins and 12 Analog Pins Enter a PWM setting to test(0-180)95 Enter a PWM setting to test(0-180)90 Enter a PWM setting to test(0-180)85 ... Note the --arduino switch passed to the calibrate command. Further note that the arduino pin being calibrated is passed via the --channel parameter. Using the arduino actuator part The following snippet illustrates how to exercise the Arduino actuator in the drive() loop: #Drive train setup arduino_controller = ArduinoFirmata( servo_pin=cfg.STEERING_ARDUINO_PIN, esc_pin=cfg.THROTTLE_ARDUINO_PIN) steering = ArdPWMSteering(controller=arduino_controller, left_pulse=cfg.STEERING_ARDUINO_LEFT_PWM, right_pulse=cfg.STEERING_ARDUINO_RIGHT_PWM) throttle = ArdPWMThrottle(controller=arduino_controller, max_pulse=cfg.THROTTLE_ARDUINO_FORWARD_PWM, zero_pulse=cfg.THROTTLE_ARDUINO_STOPPED_PWM, min_pulse=cfg.THROTTLE_ARDUINO_REVERSE_PWM) V.add(steering, inputs=['user/angle']) V.add(throttle, inputs=['user/throttle']) Refer to templates/arduino_drive.py for more details. HBridge Motor Controller and Steering Servo In this configuration the DC motor that drives the wheels is controlled by an L298N HBridge motor controller or compatible. Steering the front wheels is accomplished with a Steering Servo that takes an PWM pulse. The motor driver is wired in one of two ways; 3 pin wiring or 2 pin wiring. 3-pin HBridge and Steering Servo A single DC gear motor is controlled with an L298N using two TTL output pins to select direction and a PWM pin to control the power to the motor. See https://www.electronicshub.org/raspberry-pi-l298n-interface-tutorial-control-dc-motor-l298n-raspberry-pi/ for a discussion of how the L298N HBridge module is wired in 3-pin mode to the RaspberryPi GPIO. This also applies to the some other driver chips that emulate the L298N, such as the TB6612FNG motor driver. Configuration use DRIVETRAIN_TYPE = \"SERVO_HBRIDGE_3PIN\" in myconfig.py Example pin specifiers using 40 pin GPIO header to generate signals: HBRIDGE_3PIN_FWD = \"RPI_GPIO.BOARD.18\" # ttl pin, high enables motor forward HBRIDGE_3PIN_BWD = \"RPI_GPIO.BOARD.16\" # ttl pin, highenables motor reverse HBRIDGE_3PIN_DUTY = \"RPI_GPIO.BOARD.35\" # provides duty cycle to motor PWM_STEERING_PIN = \"RPI_GPIO.BOARD.33\" # provides servo pulse to steering servo STEERING_LEFT_PWM = 460 # pwm value for full left steering (use `donkey calibrate` to measure value for your car) STEERING_RIGHT_PWM = 290 # pwm value for full right steering (use `donkey calibrate` to measure value for your car) A PCA9685 could also be used to generate all control signals. See pins for a detailed discussion of pin providers and pin specifiers. 2-pin HBridge and Steering Servo A single DC gear motor is controlled with an 'mini' L298N HBridge (or an L9110S HBridge) using 2 PWM pins; one pwm pin to enable and control forward speed and one to enable and control reverse motor speed. See https://www.instructables.com/Tutorial-for-Dual-Channel-DC-Motor-Driver-Board-PW/ for how an L298N mini-hbridge module is wired in 2-pin mode. See https://electropeak.com/learn/interfacing-l9110s-dual-channel-h-bridge-motor-driver-module-with-arduino/ for how an L9110S/HG7881 motor driver module is wired. Configuration use DRIVETRAIN_TYPE = \"SERVO_HBRIDGE_2PIN\" in myconfig.py Example pin specifiers using 40 pin GPIO header to generate signals: HBRIDGE_2PIN_DUTY_FWD = \"RPI_GPIO.BOARD.18\" # provides forward duty cycle to motor HBRIDGE_2PIN_DUTY_BWD = \"RPI_GPIO.BOARD.16\" # provides reverse duty cycle to motor PWM_STEERING_PIN = \"RPI_GPIO.BOARD.33\" # provides servo pulse to steering servo STEERING_LEFT_PWM = 460 # pwm value for full left steering (use `donkey calibrate` to measure value for your car) STEERING_RIGHT_PWM = 290 # pwm value for full right steering (use `donkey calibrate` to measure value for your car) A PCA9685 could also be used to generate all control signals. See pins for a detailed discussion of pin providers and pin specifiers. HBridge for both Steering and Throttle Some very inexpensive toy cars use a DC motor to drive the back wheels forward and reverse and another DC motor to steer the front wheels left or right. A single L298N HBridge (or L9110S HBridge) can be used to control these two motors. This driver assumes 2-pin wiring where each motor uses two PWM pins, one for each direction. Configuration use DRIVETRAIN_TYPE = \"DC_STEER_THROTTLE\" in myconfig.py Example pin specifiers using 40 pin GPIO header to generate signals: HBRIDGE_PIN_LEFT = \"RPI_GPIO.BOARD.18\" # pwm pin produces duty cycle for steering left HBRIDGE_PIN_RIGHT = \"RPI_GPIO.BOARD.16\" # pwm pin produces duty cycle for steering right HBRIDGE_PIN_FWD = \"RPI_GPIO.BOARD.15\" # pwm pin produces duty cycle for forward drive HBRIDGE_PIN_BWD = \"RPI_GPIO.BOARD.13\" # pwm pin produces duty cycle for reverse drive A PCA9685 could also be used to generate all control signals. See pins for a detailed discussion of pin providers and pin specifiers. Differential Drive cars An inexpensive Donkeycar compatible robot can be constructed using a cheap smart car robot chassis that includes 2 DC gear motors and an L298N motor driver or compatible to run the motors. Steering is accomplished by running one motor faster than the other, causing the car to drive in an arc. The motor driver can be wired in one of two ways; 3 pin wiring or 2 pin wiring. 3-pin HBridge Differential Drive 2 DC gear motors are controlled with an L298N, each motor using two TTL output pins to select direction and a PWM pin to control the power to the motor. Since each motor uses 3 pins, so a total of 6 pins are used in a differential drive configuration. The advantage of this wiring scheme is that it only requires 2 PWM pins, which happens to be the maximum number of PWM pins on the Jetson Nano. See https://www.electronicshub.org/raspberry-pi-l298n-interface-tutorial-control-dc-motor-l298n-raspberry-pi/ for a discussion of how the L298N HBridge module is wired in 3-pin mode to the RaspberryPi GPIO. This also applies to the some other driver chips that emulate the L298N, such as the TB6612FNG motor driver. Configuration use DRIVETRAIN_TYPE = \"DC_TWO_WHEEL_L298N\" in myconfig.py Example pin specifiers using 40 pin GPIO header to generate signals: HBRIDGE_L298N_PIN_LEFT_FWD = \"RPI_GPIO.BCM.16\" # BCM.16 == BOARD.36 HBRIDGE_L298N_PIN_LEFT_BWD = \"RPI_GPIO.BCM.20\" # BCM.20 == BOARD.38 HBRIDGE_L298N_PIN_LEFT_EN = \"RPI_GPIO.BCM.12\" # BCM.12 == BOARD.32 HBRIDGE_L298N_PIN_RIGHT_FWD = \"RPI_GPIO.BCM.5\" # BCM.5 == BOARD.29 HBRIDGE_L298N_PIN_RIGHT_BWD = \"RPI_GPIO.BCM.6\" # BCM.6 == BOARD.31 HBRIDGE_L298N_PIN_RIGHT_EN = \"RPI_GPIO.BCM.13\" # BCM.13 == BOARD.33 Example pin specifiers using a PCA9685 to generate signals: HBRIDGE_L298N_PIN_LEFT_FWD = \"PCA9685.1:40.0\" HBRIDGE_L298N_PIN_LEFT_BWD = \"PCA9685.1:40.1\" HBRIDGE_L298N_PIN_LEFT_EN = \"PCA9685.1:40.2\" HBRIDGE_L298N_PIN_RIGHT_FWD = \"PCA9685.1:40.10\" HBRIDGE_L298N_PIN_RIGHT_BWD = \"PCA9685.1:40.11\" HBRIDGE_L298N_PIN_RIGHT_EN = \"PCA9685.1:40.13\" In the configuration, the HBRIDGE_L298N_PIN_xxxx_EN pins determine how fast the motors spin. These pins must support PWM output. Remember that the Jetson Nano only supports 2 PWM output pins and only if they are enabled using /opt/nvidia/jetson-io/jetson-io.py . See Generating PWM from the Jetson Nano . The HBRIDGE_L298N_PIN_xxxx_FWD and HBRIDGE_L298N_PIN_xxxx_BWD pins are TTL output pins that determine the direction the motors spin. See pins for a detailed discussion of pin providers and pin specifiers. 2 Pin HBridge Differential Drive 2 DC Motors controlled with an 'mini' L298N HBridge, each motor using 2 PWM pins; one pwm pin to enable and control forward speed and one to enable and control reverse motor speed. This advantage of this wiring method is that it only requires a total of 4 pins. See https://www.instructables.com/Tutorial-for-Dual-Channel-DC-Motor-Driver-Board-PW/ for how an L298N mini-HBridge modules is wired in 2-pin mode. This driver can also be used with an L9110S/HG7881 motor driver. See https://electropeak.com/learn/interfacing-l9110s-dual-channel-h-bridge-motor-driver-module-with-arduino/ for how an L9110S motor driver module is wired. Configuration use DRIVETRAIN_TYPE = \"DC_TWO_WHEEL\" in myconfig.py example pin specifiers using the 40 pin GPIO to generate signals: HBRIDGE_PIN_LEFT_FWD = \"RPI_GPIO.BCM.16\" # BCM.16 == BOARD.36 HBRIDGE_PIN_LEFT_BWD = \"RPI_GPIO.BCM.20\" # BCM.20 == BOARD.38 HBRIDGE_PIN_RIGHT_FWD = \"RPI_GPIO.BCM.5\" # BCM.5 == BOARD.29 HBRIDGE_PIN_RIGHT_BWD = \"RPI_GPIO.BCM.6\" # BCM.6 == BOARD.31 example pin specifiers using a PCA9685 to generate signals: HBRIDGE_PIN_LEFT_FWD = \"PCA9685.1:40.0\" HBRIDGE_PIN_LEFT_BWD = \"PCA9685.1:40.1\" HBRIDGE_PIN_RIGHT_FWD = \"PCA9685.1:40.5\" HBRIDGE_PIN_RIGHT_BWD = \"PCA9685.1:40.6\" See pins for a detailed discussion of pin providers and pin specifiers.","title":"Actuators"},{"location":"parts/actuators/#actuators","text":"A car needs a way to to move forward and backward and to turn left and right. We commonly call devices that produce a physical movement in the robot 'actuators'. Common actuators are DC motors, Servo motors, continuous servo motors and stepper motors. There are many, many different ways that these actuators can be combined to propel and turn a robot. Donkeycar supports two common configurations that can be implemented with various actuators: Car-like vehicles steer by angling the front wheels left or right and move by turning the drive wheels forward or reverse. Common RC cars fall in this category. Differential drive vehicles have two independently controlled drive wheels to provide both movement and steering. For instance a differential drive car can be driven straight forward by turning the two drive wheels forward at the same speed. In order to turn, one motor can be driven faster than the other and the car will turn an arc in the direction of the slower motor. Actuators take control signals from the Donkeycar to control their actions. There are several options for generating these control signals. - PCA9685 Servo controller board - RPi/Jetson 40 pin GPIO header - see Generating PWM from the Jetson Nano for how to enable PWM output from the Jetson Nano 40 pin GPIO header. - Arduino Below we will describe the supported actuator setups and software configuration of their control signals.","title":"Actuators"},{"location":"parts/actuators/#standard-rc-with-esc-and-steering-servo","text":"A standard RC car is equipped with a steering servo for steering the front wheels and an ESC (Electronic Speed Controller) to control the speed of the DC motor driving the wheels. Both the steering servo and the ESC take a PWM (Pulse Width Modulation) control signal. A PWM signal is simply a square wave pulse of a certain duration and frequency. In the case of the steering servo the PWM signal determines the position of the servo's arm, which is generally between 0 degrees (full right) and 180 degrees (full left). In the case of the ESC the PWM signal determines the direction and speed of the drive motor, from full reverse, through stopped, to full forward. Standard RC servo pulses range from 1 millisecond (full reverse for ESC, fully left for servo) to 2 milliseconds (full forward for ESC, full right for servo) with 1.5 milliseconds being neutral (stopped for ESC, straight for servo). These pulses are typically sent at 50 hertz (one duty cycle every 20 milliseconds). One duty cycle includes a period where the signal is brought high followed by a period where the signal is brought low. This means that, using the standard 50hz frequency, a 1 millisecond pulse (1 ms high followed by 19 ms low) represents a 5% duty cycle and a 2 millisecond pulse represents a 10% duty cycle. The most important part is the length of the pulse; it must be in the range of 1 to 2 milliseconds. So this means that if a different frequency is used, then the duty cycle must be adjusted in order to get the 1ms to 2ms pulse. For instance, if a 60hz frequency is used, then a 1 ms pulse requires a duty cycle of 0.05 * 60 / 50 = 0.06 (6%) duty cycle We default the frequency of our PCA9685 to 60 hz, so pulses in config are generally based on 60hz frequency and 12 bit values. We use 12 bit values because the PCA9685 has 12 bit resolution. So a 1 ms pulse is 0.06 * 4096 ~= 246, a neutral pulse of 0.09 duty cycle is 0.09 * 4096 ~= 367 and full forward pulse of 0.12 duty cycles is 0.12 * 4096 ~= 492 These are generalizations that are useful for understanding the underlying api call arguments and the values that are generating when calibrating. The final choice of duty-cycle/pulse length depends on your hardware and perhaps your strategy (you may not want to go too fast, and so you may choose is low max throttle pwm)","title":"Standard RC with ESC and Steering Servo."},{"location":"parts/actuators/#generating-pwm-pulses-with-a-pca9685-servo-controller","text":"The hardware connection of the PCA9685 I2C servo driver board is described fully in the overall setup instructions here The PCA9685 Servo controller is connected the RaspberryPi or Jetson Nano via the I2C pins on the 40 Pin bus, then the 3 pin cables from the ESC and Steering Servo are connected to the PCA9685, generally to channel 0 and channel 1 respectively. See Step 4: Connect Servo Shield . Connection of a PCA9685 to a Jetson Nano is the same. Configuration Use DRIVE_TRAIN_TYPE = \"PWM_STEERING_THROTTLE\" in myconfig.py Set the pin specifiers for PCA9685 in the # PWM_STEERING_THROTTLE section of myconfig.py. For example: PWM_STEERING_PIN = \"PCA9685.1:40.0\" # PCA9685, I2C bus 1, address 0x40, channel 0 PWM_THROTTLE_PIN = \"PCA9685.1:40.1\" # PCA9685, I2C bus 1, address 0x40, channel 1 See pins for a detailed discussion of pin providers and pin specifiers.","title":"Generating PWM pulses with a PCA9685 Servo controller"},{"location":"parts/actuators/#generating-pwm-pulses-from-the-40-pin-gpio-header","text":"Here the PWM signal is generated from the 40 pin GPIO header. The data pin on the 3-pin ESC and Servo connectors are connected to a PWM pin on the GPIO. The ground pins on the 3-pin connectors are connected to a common ground. The 5V pins on the 3-pin connectors are connected to the 5V pins on the GPIO: the 3-pin connector from the ESC will generally provide 5V that can then be used to power the Servo. Configuration Use DRIVE_TRAIN_TYPE = \"PWM_STEERING_THROTTLE\" in myconfig.py Set the pin specifiers for GPIO in the # PWM_STEERING_THROTTLE section. Note that each pin has both a BOARD mode and a BCM (Broadcom) mode identifier. You can use either mode, but all pins must use the same mode. For example: PWM_STEERING_PIN = \"RPI_GPIO.BOARD.33\" # GPIO board mode pin-33 == BCM mode pin-13 PWM_THROTTLE_PIN = \"RPI_GPIO.BOARD.12\" # GPIO board mode pin-12 == BCM mode pin-18 See pins for a detailed discussion of pin providers and pin specifiers.","title":"Generating PWM pulses from the 40 pin GPIO header"},{"location":"parts/actuators/#direct-control-with-the-raspberrypi-gpio-pins","text":"Please follow the instructions here","title":"Direct control with the RaspberryPi GPIO pins."},{"location":"parts/actuators/#control-with-the-robo-hat-mm1-board","text":"Please follow the instructions here","title":"Control with the Robo HAT MM1 board."},{"location":"parts/actuators/#arduino","text":"Arduino can be used in the following fashion to generate PWM signals to control the steering and throttle. For now the Arduino mode is only tested on the Latte Panda Delta (LP-D) board. However it should be straightforward to use it with Raspberry Pi / Jetson Nano (instead of PCA 9685). Refer to the below block diagram to understand where things fits in. Arduino board should be running the standard firmata sketch (This sketch comes by default when you download the arduino tool). Load the standard firmata sketch (from Examples > Firmata > StandardFirmata ) onto the Arduino. Further pymata_aio_ python package needs to be installed on the car computer via pip3 install pymata_aio . As shown in the block-diagram above LattePanda combines both the x86 CPU and the Connected Arduino into a single board. The following diagram shows how to connect the Arduino pins to steering servo and ESC. Note that the power for the servo is provided by the ESC battery elemininator circuit (BEC) which most ESC's provide. This is done to avoid supplying the entire servo power from Arduino's 5v. In large RC cars the servo can drag up to 2 amps, which lead to a destruction of the Arduino.","title":"Arduino"},{"location":"parts/actuators/#calibration","text":"Note that the calibration procedure/values are slightly different for the Arduino (than PCA9685). Note that 90 is the usual midpoint (i.e. 1.5 ms pulse width at 50 Hz), so it is recommended to start with 90 and adjust +/- 5 until you figure the desired range for steering / throttle. (env1) jithu@jithu-lp:~/master/pred_mt/lp/001/donkey$ donkey calibrate --arduino --channel 6 using donkey v2.6.0t ... pymata_aio Version 2.33 Copyright (c) 2015-2018 Alan Yorinks All rights reserved. Using COM Port:/dev/ttyACM0 Initializing Arduino - Please wait... Arduino Firmware ID: 2.5 StandardFirmata.ino Auto-discovery complete. Found 30 Digital Pins and 12 Analog Pins Enter a PWM setting to test(0-180)95 Enter a PWM setting to test(0-180)90 Enter a PWM setting to test(0-180)85 ... Note the --arduino switch passed to the calibrate command. Further note that the arduino pin being calibrated is passed via the --channel parameter.","title":"Calibration"},{"location":"parts/actuators/#using-the-arduino-actuator-part","text":"The following snippet illustrates how to exercise the Arduino actuator in the drive() loop: #Drive train setup arduino_controller = ArduinoFirmata( servo_pin=cfg.STEERING_ARDUINO_PIN, esc_pin=cfg.THROTTLE_ARDUINO_PIN) steering = ArdPWMSteering(controller=arduino_controller, left_pulse=cfg.STEERING_ARDUINO_LEFT_PWM, right_pulse=cfg.STEERING_ARDUINO_RIGHT_PWM) throttle = ArdPWMThrottle(controller=arduino_controller, max_pulse=cfg.THROTTLE_ARDUINO_FORWARD_PWM, zero_pulse=cfg.THROTTLE_ARDUINO_STOPPED_PWM, min_pulse=cfg.THROTTLE_ARDUINO_REVERSE_PWM) V.add(steering, inputs=['user/angle']) V.add(throttle, inputs=['user/throttle']) Refer to templates/arduino_drive.py for more details.","title":"Using the arduino actuator part"},{"location":"parts/actuators/#hbridge-motor-controller-and-steering-servo","text":"In this configuration the DC motor that drives the wheels is controlled by an L298N HBridge motor controller or compatible. Steering the front wheels is accomplished with a Steering Servo that takes an PWM pulse. The motor driver is wired in one of two ways; 3 pin wiring or 2 pin wiring.","title":"HBridge Motor Controller and Steering Servo"},{"location":"parts/actuators/#3-pin-hbridge-and-steering-servo","text":"A single DC gear motor is controlled with an L298N using two TTL output pins to select direction and a PWM pin to control the power to the motor. See https://www.electronicshub.org/raspberry-pi-l298n-interface-tutorial-control-dc-motor-l298n-raspberry-pi/ for a discussion of how the L298N HBridge module is wired in 3-pin mode to the RaspberryPi GPIO. This also applies to the some other driver chips that emulate the L298N, such as the TB6612FNG motor driver. Configuration use DRIVETRAIN_TYPE = \"SERVO_HBRIDGE_3PIN\" in myconfig.py Example pin specifiers using 40 pin GPIO header to generate signals: HBRIDGE_3PIN_FWD = \"RPI_GPIO.BOARD.18\" # ttl pin, high enables motor forward HBRIDGE_3PIN_BWD = \"RPI_GPIO.BOARD.16\" # ttl pin, highenables motor reverse HBRIDGE_3PIN_DUTY = \"RPI_GPIO.BOARD.35\" # provides duty cycle to motor PWM_STEERING_PIN = \"RPI_GPIO.BOARD.33\" # provides servo pulse to steering servo STEERING_LEFT_PWM = 460 # pwm value for full left steering (use `donkey calibrate` to measure value for your car) STEERING_RIGHT_PWM = 290 # pwm value for full right steering (use `donkey calibrate` to measure value for your car) A PCA9685 could also be used to generate all control signals. See pins for a detailed discussion of pin providers and pin specifiers.","title":"3-pin HBridge and Steering Servo"},{"location":"parts/actuators/#2-pin-hbridge-and-steering-servo","text":"A single DC gear motor is controlled with an 'mini' L298N HBridge (or an L9110S HBridge) using 2 PWM pins; one pwm pin to enable and control forward speed and one to enable and control reverse motor speed. See https://www.instructables.com/Tutorial-for-Dual-Channel-DC-Motor-Driver-Board-PW/ for how an L298N mini-hbridge module is wired in 2-pin mode. See https://electropeak.com/learn/interfacing-l9110s-dual-channel-h-bridge-motor-driver-module-with-arduino/ for how an L9110S/HG7881 motor driver module is wired. Configuration use DRIVETRAIN_TYPE = \"SERVO_HBRIDGE_2PIN\" in myconfig.py Example pin specifiers using 40 pin GPIO header to generate signals: HBRIDGE_2PIN_DUTY_FWD = \"RPI_GPIO.BOARD.18\" # provides forward duty cycle to motor HBRIDGE_2PIN_DUTY_BWD = \"RPI_GPIO.BOARD.16\" # provides reverse duty cycle to motor PWM_STEERING_PIN = \"RPI_GPIO.BOARD.33\" # provides servo pulse to steering servo STEERING_LEFT_PWM = 460 # pwm value for full left steering (use `donkey calibrate` to measure value for your car) STEERING_RIGHT_PWM = 290 # pwm value for full right steering (use `donkey calibrate` to measure value for your car) A PCA9685 could also be used to generate all control signals. See pins for a detailed discussion of pin providers and pin specifiers.","title":"2-pin HBridge and Steering Servo"},{"location":"parts/actuators/#hbridge-for-both-steering-and-throttle","text":"Some very inexpensive toy cars use a DC motor to drive the back wheels forward and reverse and another DC motor to steer the front wheels left or right. A single L298N HBridge (or L9110S HBridge) can be used to control these two motors. This driver assumes 2-pin wiring where each motor uses two PWM pins, one for each direction. Configuration use DRIVETRAIN_TYPE = \"DC_STEER_THROTTLE\" in myconfig.py Example pin specifiers using 40 pin GPIO header to generate signals: HBRIDGE_PIN_LEFT = \"RPI_GPIO.BOARD.18\" # pwm pin produces duty cycle for steering left HBRIDGE_PIN_RIGHT = \"RPI_GPIO.BOARD.16\" # pwm pin produces duty cycle for steering right HBRIDGE_PIN_FWD = \"RPI_GPIO.BOARD.15\" # pwm pin produces duty cycle for forward drive HBRIDGE_PIN_BWD = \"RPI_GPIO.BOARD.13\" # pwm pin produces duty cycle for reverse drive A PCA9685 could also be used to generate all control signals. See pins for a detailed discussion of pin providers and pin specifiers.","title":"HBridge for both Steering and Throttle"},{"location":"parts/actuators/#differential-drive-cars","text":"An inexpensive Donkeycar compatible robot can be constructed using a cheap smart car robot chassis that includes 2 DC gear motors and an L298N motor driver or compatible to run the motors. Steering is accomplished by running one motor faster than the other, causing the car to drive in an arc. The motor driver can be wired in one of two ways; 3 pin wiring or 2 pin wiring.","title":"Differential Drive cars"},{"location":"parts/actuators/#3-pin-hbridge-differential-drive","text":"2 DC gear motors are controlled with an L298N, each motor using two TTL output pins to select direction and a PWM pin to control the power to the motor. Since each motor uses 3 pins, so a total of 6 pins are used in a differential drive configuration. The advantage of this wiring scheme is that it only requires 2 PWM pins, which happens to be the maximum number of PWM pins on the Jetson Nano. See https://www.electronicshub.org/raspberry-pi-l298n-interface-tutorial-control-dc-motor-l298n-raspberry-pi/ for a discussion of how the L298N HBridge module is wired in 3-pin mode to the RaspberryPi GPIO. This also applies to the some other driver chips that emulate the L298N, such as the TB6612FNG motor driver. Configuration use DRIVETRAIN_TYPE = \"DC_TWO_WHEEL_L298N\" in myconfig.py Example pin specifiers using 40 pin GPIO header to generate signals: HBRIDGE_L298N_PIN_LEFT_FWD = \"RPI_GPIO.BCM.16\" # BCM.16 == BOARD.36 HBRIDGE_L298N_PIN_LEFT_BWD = \"RPI_GPIO.BCM.20\" # BCM.20 == BOARD.38 HBRIDGE_L298N_PIN_LEFT_EN = \"RPI_GPIO.BCM.12\" # BCM.12 == BOARD.32 HBRIDGE_L298N_PIN_RIGHT_FWD = \"RPI_GPIO.BCM.5\" # BCM.5 == BOARD.29 HBRIDGE_L298N_PIN_RIGHT_BWD = \"RPI_GPIO.BCM.6\" # BCM.6 == BOARD.31 HBRIDGE_L298N_PIN_RIGHT_EN = \"RPI_GPIO.BCM.13\" # BCM.13 == BOARD.33 Example pin specifiers using a PCA9685 to generate signals: HBRIDGE_L298N_PIN_LEFT_FWD = \"PCA9685.1:40.0\" HBRIDGE_L298N_PIN_LEFT_BWD = \"PCA9685.1:40.1\" HBRIDGE_L298N_PIN_LEFT_EN = \"PCA9685.1:40.2\" HBRIDGE_L298N_PIN_RIGHT_FWD = \"PCA9685.1:40.10\" HBRIDGE_L298N_PIN_RIGHT_BWD = \"PCA9685.1:40.11\" HBRIDGE_L298N_PIN_RIGHT_EN = \"PCA9685.1:40.13\" In the configuration, the HBRIDGE_L298N_PIN_xxxx_EN pins determine how fast the motors spin. These pins must support PWM output. Remember that the Jetson Nano only supports 2 PWM output pins and only if they are enabled using /opt/nvidia/jetson-io/jetson-io.py . See Generating PWM from the Jetson Nano . The HBRIDGE_L298N_PIN_xxxx_FWD and HBRIDGE_L298N_PIN_xxxx_BWD pins are TTL output pins that determine the direction the motors spin. See pins for a detailed discussion of pin providers and pin specifiers.","title":"3-pin HBridge Differential Drive"},{"location":"parts/actuators/#2-pin-hbridge-differential-drive","text":"2 DC Motors controlled with an 'mini' L298N HBridge, each motor using 2 PWM pins; one pwm pin to enable and control forward speed and one to enable and control reverse motor speed. This advantage of this wiring method is that it only requires a total of 4 pins. See https://www.instructables.com/Tutorial-for-Dual-Channel-DC-Motor-Driver-Board-PW/ for how an L298N mini-HBridge modules is wired in 2-pin mode. This driver can also be used with an L9110S/HG7881 motor driver. See https://electropeak.com/learn/interfacing-l9110s-dual-channel-h-bridge-motor-driver-module-with-arduino/ for how an L9110S motor driver module is wired. Configuration use DRIVETRAIN_TYPE = \"DC_TWO_WHEEL\" in myconfig.py example pin specifiers using the 40 pin GPIO to generate signals: HBRIDGE_PIN_LEFT_FWD = \"RPI_GPIO.BCM.16\" # BCM.16 == BOARD.36 HBRIDGE_PIN_LEFT_BWD = \"RPI_GPIO.BCM.20\" # BCM.20 == BOARD.38 HBRIDGE_PIN_RIGHT_FWD = \"RPI_GPIO.BCM.5\" # BCM.5 == BOARD.29 HBRIDGE_PIN_RIGHT_BWD = \"RPI_GPIO.BCM.6\" # BCM.6 == BOARD.31 example pin specifiers using a PCA9685 to generate signals: HBRIDGE_PIN_LEFT_FWD = \"PCA9685.1:40.0\" HBRIDGE_PIN_LEFT_BWD = \"PCA9685.1:40.1\" HBRIDGE_PIN_RIGHT_FWD = \"PCA9685.1:40.5\" HBRIDGE_PIN_RIGHT_BWD = \"PCA9685.1:40.6\" See pins for a detailed discussion of pin providers and pin specifiers.","title":"2 Pin HBridge Differential Drive"},{"location":"parts/controllers/","text":"Controller Parts Web Controller The default controller to drive the car with your phone or browser. This has a web live preview of camera. Control options include: A virtual joystick The tilt, when using a mobile device with supported accelerometer A physical joystick using the web adapter. Support varies per browser, OS, and joystick combination. Keyboard input via the 'ikjl' keys. Note: Recently iOS has disabled default Safari access to motion control. RC Controller If you bought an RC car then it might have come with a standard 2.4GHz car radio and receiver as shown in picture below. This can be used to drive the car. You can also use the RaspberryPi pins to output directly to the car's servo and motor controller, without the need for an I2C servo driver board. A full tutorial on doing this is here . Joystick Controller Many people find it easier to control the car using a game controller. There are several parts that provide this option. The default web controller may be replaced with a one line change to use a physical joystick part for input. This uses the OS device /dev/input/js0 by default. In theory, any joystick device that the OS mounts like this can be used. In practice, the behavior will change depending on the model of joystick ( Sony, or knockoff ), or XBox controller and the Bluetooth driver used to support it. The default code has been written and tested with a Sony brand PS3 Sixaxis controller . Other controllers may work, but will require alternative Bluetooth installs, and tweaks to the software for correct axis and buttons. These joysticks are known to work: Logitech Gamepad F710 Sony PS3 Sixaxis OEM (Not compatible with Jetson Nano) Sony PS4 Dualshock OEM WiiU Pro XBox Controller SteelSeries Nimbus (works only on TX2 jetpack 4.2+, may work on the Nano) These can be enabled by finding the CONTROLLER_TYPE in your myconfig.py and setting it to the correct string identifier ( after disabling the comment ). These can be used plugged in with a USB cable. It's been much more convenient to setup Bluetooth for a wireless control. There are controller specific setup details below. Note: If you have a controller that is not listed below, or you are having troubles getting your controller to work or you want to map your controller differently, see Creating a New or Custom Game Controller . Change myconfig.py or run with --js python manage.py drive --js Will enable driving with the joystick. This disables the live preview of the camera and the web page features. If you modify myconfig.py to make USE_JOYSTICK_AS_DEFAULT = True , then you do not need to run with the --js . PS3 Controller Bluetooth Setup Follow this guide . You can ignore steps past the 'Accessing the SixAxis from Python' section. I will include steps here in case the link becomes stale. sudo apt-get install bluetooth libbluetooth3 libusb-dev sudo systemctl enable bluetooth.service sudo usermod -G bluetooth -a pi Reboot after changing the user group. Plug in the PS3 with USB cable. Hit center PS logo button. Get and build the command line pairing tool. Run it: wget http://www.pabr.org/sixlinux/sixpair.c gcc -o sixpair sixpair.c -lusb sudo ./sixpair Use bluetoothctl to pair bluetoothctl agent on devices trust <MAC ADDRESS> default-agent quit Unplug USB cable. Hit center PS logo button. To test that the Bluetooth PS3 remote is working, verify that /dev/input/js0 exists: ls /dev/input/js0 Troubleshooting In case the BT connection on the Raspberry Pi does not work, you see might something like this in bluetoothctl : [NEW] Controller 00:11:22:33:44:55 super-donkey [default] [NEW] Device AA:BB:CC:DD:EE:FF PLAYSTATION(R)3 Controller [CHG] Device AA:BB:CC:DD:EE:FF Connected: yes [CHG] Device AA:BB:CC:DD:EE:FF Connected: no [CHG] Device AA:BB:CC:DD:EE:FF Connected: yes [CHG] Device AA:BB:CC:DD:EE:FF Connected: no [CHG] Device AA:BB:CC:DD:EE:FF Connected: yes ... [CHG] Device AA:BB:CC:DD:EE:FF Connected: yes [CHG] Device AA:BB:CC:DD:EE:FF Connected: no [bluetooth]# Try updating the Linux kernel and firmware by running: sudo rpi-update And then reboot: sudo reboot Charging PS3 Sixaxis Joystick For some reason, they don't like to charge in a powered USB port that doesn't have an active Bluetooth control and OS driver. This means a phone type USB charger will not work. Try a powered Linux or mac laptop USB port. You should see the lights blink after plugging in and hitting center PS logo. After charging, you will need to plug-in the controller again to the Pi, hit the PS logo, then unplug to pair again. New Battery for PS3 Sixaxis Joystick Sometimes these controllers can be quite old. Here's a link to a new battery . Be careful when taking off the cover. Remove 5 screws. There's a tab on the top half between the hand grips. You'll want to split/open it from the front and try pulling the bottom forward as you do, or you'll break the tab off as I did. PS3 Mouse problems on Linux Sometimes when you plug-in the PS3 joystick it starts taking over your mouse. If you want to prevent that, you can run this: xinput set-prop \"Sony PLAYSTATION(R)3 Controller\" \"Device Enabled\" 0 PS4 Controller The following instructions are based on RetroPie and ds4drv . Install ds4drv Running on your pi over ssh, you can directly install it: sudo /home/pi/env/bin/pip install ds4drv Grant permission to ds4drv sudo wget https://raw.githubusercontent.com/chrippa/ds4drv/master/udev/50-ds4drv.rules -O /etc/udev/rules.d/50-ds4drv.rules sudo udevadm control --reload-rules sudo udevadm trigger Run ds4drv ds4drv --hidraw --led 00ff00 If you see Failed to create input device: \"/dev/uinput\" cannot be opened for writing , reboot and retry. Probably granting permission step doesn't take effect until rebooting. Some controllers don't work with --hidraw . If that's the case try the command without it. --led 00ff00 changes the light bar color, it's optional. Start controller in pairing mode Press and hold Share button, then press and hold PS button until the light bar starts blinking. If it goes green after a few seconds, pairing is successful. Run ds4drv in background on startup once booted sudo nano /etc/rc.local paste: /home/pi/env/bin/ds4drv --led 00ff00 Save and exit. Again, with or without --hidraw , depending on the particular controller you are using. To disconnect, kill the process ds4drv and hold PS for 10 seconds to power off the controller. XBox One Controller bluetooth pairing This code presumes the built-in linux driver for 'Xbox Wireless Controller'; this is pre-installed on Raspbian, so there is no need to install any other drivers. This will generally show up on /dev/input/js0. There is another userland driver called xboxdrv; this code has not been tested with that driver. The XBox One controller requires that the bluetooth disable_ertm parameter be set to true; to do this: Jetson Nano Adapted from: https://www.roboticsbuildlog.com/hardware/xbox-one-controller-with-nvidia-jetson-nano Install these python libraries before we disable ertm. sudo apt-get install nano Add Non-root access to your input folder: sudo usermod -a -G dialout $USER sudo reboot Install sysfsutils sudo apt-get install sysfsutils Edit the config to disable bluetooth ertm sudo nano /etc/sysfs.conf Append this to the end of the config /module/bluetooth/parameters/disable_ertm=1 Reboot your computer sudo reboot Re-pair the Xbox One Bluetooth Controller Unpair (forget) the controller first if you already tried to pair it, then pair it again. You can do this with the Bluetooth Manager GUI appliation that ships with Jetpack or if you are using command line, then use bluetoothctl: Open terminal and type: bluetoothctl then you should see the list of devices you have paired with and their corresponding MAC address. If you do not, type: paired-devices To un-pair a device type (replace aa:bb:cc:dd:ee:ff with the MAC address of the device to un-pair): remove aa:bb:cc:dd:ee:ff exit Pair your device using either Bluetooth Manager GUI or bluetoothctl (see RaspberryPi OS instruction starting with sudo bluetoothctl ) Once paired you should have a solid light on the xbox button and a stable bluetooth connection. RaspberryPi OS edit the file /etc/modprobe.d/xbox_bt.conf (that may create the file; it is commonly not there by default) add the line: options bluetooth disable_ertm=1 reboot so that this takes affect. after reboot you can verify that disable_ertm is set to true entering this command in a terminal: bash cat /sys/module/bluetooth/parameters/disable_ertm the result should print 'Y'. If not, make sure the above steps have been done correctly. Once that is done, you can pair your controller to your Raspberry Pi using the bluetooth tool. Enter the following command into a bash shell prompt: sudo bluetoothctl That will start blue tooth pairing in interactive mode. The remaining commands will be entered in that interactive session. Enter the following commands: agent on default-agent scan on That last command will start the Raspberry Pi scanning for new bluetooth devices. At this point, turn on your XBox One controller using the big round 'X' button on top, then start the pairing mode by pressing the 'sync' button on the front of the controller. Within a few minutes, you should see the controller show up in the output something like this; [NEW] Device B8:27:EB:A4:59:08 XBox One Wireless Controller Write down the MAC address, you will need it for the following steps. Enter this command to pair with your controller: connect YOUR_MAC_ADDRESS where YOUR_MAC_ADDRESS is the MAC address you copied previously. If it does not connect on the first try, try again. It can take a few tries. If your controller connects, but then immediately disconnects, your disable_ertm setting might be wrong (see above). Once your controller is connected, the big round 'X' button on the top of your controller should be solid white. Enter the following commands to finish: trust YOUR_MAC_ADDRESS quit Now that your controller is trusted, it should automatically connect with your Raspberry Pi when they are both turned on. If your controller fails to connect, run the bluetoothctl steps again to reconnect. Creating a New or Custom Game Controller To discover or modify the button and axis mappings for your controller, you can use the Joystick Wizard . The Joystick Wizard will write a custom controller named 'my_joystick.py' to your mycar folder. To use the custom controller, set CONTROLLER_TYPE=\"custom\" in your myconfig.py.","title":"Controller Parts"},{"location":"parts/controllers/#controller-parts","text":"","title":"Controller Parts"},{"location":"parts/controllers/#web-controller","text":"The default controller to drive the car with your phone or browser. This has a web live preview of camera. Control options include: A virtual joystick The tilt, when using a mobile device with supported accelerometer A physical joystick using the web adapter. Support varies per browser, OS, and joystick combination. Keyboard input via the 'ikjl' keys. Note: Recently iOS has disabled default Safari access to motion control.","title":"Web Controller"},{"location":"parts/controllers/#rc-controller","text":"If you bought an RC car then it might have come with a standard 2.4GHz car radio and receiver as shown in picture below. This can be used to drive the car. You can also use the RaspberryPi pins to output directly to the car's servo and motor controller, without the need for an I2C servo driver board. A full tutorial on doing this is here .","title":"RC Controller"},{"location":"parts/controllers/#joystick-controller","text":"Many people find it easier to control the car using a game controller. There are several parts that provide this option. The default web controller may be replaced with a one line change to use a physical joystick part for input. This uses the OS device /dev/input/js0 by default. In theory, any joystick device that the OS mounts like this can be used. In practice, the behavior will change depending on the model of joystick ( Sony, or knockoff ), or XBox controller and the Bluetooth driver used to support it. The default code has been written and tested with a Sony brand PS3 Sixaxis controller . Other controllers may work, but will require alternative Bluetooth installs, and tweaks to the software for correct axis and buttons.","title":"Joystick Controller"},{"location":"parts/controllers/#these-joysticks-are-known-to-work","text":"Logitech Gamepad F710 Sony PS3 Sixaxis OEM (Not compatible with Jetson Nano) Sony PS4 Dualshock OEM WiiU Pro XBox Controller SteelSeries Nimbus (works only on TX2 jetpack 4.2+, may work on the Nano) These can be enabled by finding the CONTROLLER_TYPE in your myconfig.py and setting it to the correct string identifier ( after disabling the comment ). These can be used plugged in with a USB cable. It's been much more convenient to setup Bluetooth for a wireless control. There are controller specific setup details below. Note: If you have a controller that is not listed below, or you are having troubles getting your controller to work or you want to map your controller differently, see Creating a New or Custom Game Controller .","title":"These joysticks are known to work:"},{"location":"parts/controllers/#change-myconfigpy-or-run-with-js","text":"python manage.py drive --js Will enable driving with the joystick. This disables the live preview of the camera and the web page features. If you modify myconfig.py to make USE_JOYSTICK_AS_DEFAULT = True , then you do not need to run with the --js .","title":"Change myconfig.py or run with --js"},{"location":"parts/controllers/#ps3-controller","text":"","title":"PS3 Controller"},{"location":"parts/controllers/#bluetooth-setup","text":"Follow this guide . You can ignore steps past the 'Accessing the SixAxis from Python' section. I will include steps here in case the link becomes stale. sudo apt-get install bluetooth libbluetooth3 libusb-dev sudo systemctl enable bluetooth.service sudo usermod -G bluetooth -a pi Reboot after changing the user group. Plug in the PS3 with USB cable. Hit center PS logo button. Get and build the command line pairing tool. Run it: wget http://www.pabr.org/sixlinux/sixpair.c gcc -o sixpair sixpair.c -lusb sudo ./sixpair Use bluetoothctl to pair bluetoothctl agent on devices trust <MAC ADDRESS> default-agent quit Unplug USB cable. Hit center PS logo button. To test that the Bluetooth PS3 remote is working, verify that /dev/input/js0 exists: ls /dev/input/js0","title":"Bluetooth Setup"},{"location":"parts/controllers/#troubleshooting","text":"In case the BT connection on the Raspberry Pi does not work, you see might something like this in bluetoothctl : [NEW] Controller 00:11:22:33:44:55 super-donkey [default] [NEW] Device AA:BB:CC:DD:EE:FF PLAYSTATION(R)3 Controller [CHG] Device AA:BB:CC:DD:EE:FF Connected: yes [CHG] Device AA:BB:CC:DD:EE:FF Connected: no [CHG] Device AA:BB:CC:DD:EE:FF Connected: yes [CHG] Device AA:BB:CC:DD:EE:FF Connected: no [CHG] Device AA:BB:CC:DD:EE:FF Connected: yes ... [CHG] Device AA:BB:CC:DD:EE:FF Connected: yes [CHG] Device AA:BB:CC:DD:EE:FF Connected: no [bluetooth]# Try updating the Linux kernel and firmware by running: sudo rpi-update And then reboot: sudo reboot","title":"Troubleshooting"},{"location":"parts/controllers/#charging-ps3-sixaxis-joystick","text":"For some reason, they don't like to charge in a powered USB port that doesn't have an active Bluetooth control and OS driver. This means a phone type USB charger will not work. Try a powered Linux or mac laptop USB port. You should see the lights blink after plugging in and hitting center PS logo. After charging, you will need to plug-in the controller again to the Pi, hit the PS logo, then unplug to pair again.","title":"Charging PS3 Sixaxis Joystick"},{"location":"parts/controllers/#new-battery-for-ps3-sixaxis-joystick","text":"Sometimes these controllers can be quite old. Here's a link to a new battery . Be careful when taking off the cover. Remove 5 screws. There's a tab on the top half between the hand grips. You'll want to split/open it from the front and try pulling the bottom forward as you do, or you'll break the tab off as I did.","title":"New Battery for PS3 Sixaxis Joystick"},{"location":"parts/controllers/#ps3-mouse-problems-on-linux","text":"Sometimes when you plug-in the PS3 joystick it starts taking over your mouse. If you want to prevent that, you can run this: xinput set-prop \"Sony PLAYSTATION(R)3 Controller\" \"Device Enabled\" 0","title":"PS3 Mouse problems on Linux"},{"location":"parts/controllers/#ps4-controller","text":"The following instructions are based on RetroPie and ds4drv .","title":"PS4 Controller"},{"location":"parts/controllers/#install-ds4drv","text":"Running on your pi over ssh, you can directly install it: sudo /home/pi/env/bin/pip install ds4drv","title":"Install ds4drv"},{"location":"parts/controllers/#grant-permission-to-ds4drv","text":"sudo wget https://raw.githubusercontent.com/chrippa/ds4drv/master/udev/50-ds4drv.rules -O /etc/udev/rules.d/50-ds4drv.rules sudo udevadm control --reload-rules sudo udevadm trigger","title":"Grant permission to ds4drv"},{"location":"parts/controllers/#run-ds4drv","text":"ds4drv --hidraw --led 00ff00 If you see Failed to create input device: \"/dev/uinput\" cannot be opened for writing , reboot and retry. Probably granting permission step doesn't take effect until rebooting. Some controllers don't work with --hidraw . If that's the case try the command without it. --led 00ff00 changes the light bar color, it's optional.","title":"Run ds4drv"},{"location":"parts/controllers/#start-controller-in-pairing-mode","text":"Press and hold Share button, then press and hold PS button until the light bar starts blinking. If it goes green after a few seconds, pairing is successful.","title":"Start controller in pairing mode"},{"location":"parts/controllers/#run-ds4drv-in-background-on-startup-once-booted","text":"sudo nano /etc/rc.local paste: /home/pi/env/bin/ds4drv --led 00ff00 Save and exit. Again, with or without --hidraw , depending on the particular controller you are using. To disconnect, kill the process ds4drv and hold PS for 10 seconds to power off the controller.","title":"Run ds4drv in background on startup once booted"},{"location":"parts/controllers/#xbox-one-controller","text":"","title":"XBox One Controller"},{"location":"parts/controllers/#bluetooth-pairing","text":"This code presumes the built-in linux driver for 'Xbox Wireless Controller'; this is pre-installed on Raspbian, so there is no need to install any other drivers. This will generally show up on /dev/input/js0. There is another userland driver called xboxdrv; this code has not been tested with that driver. The XBox One controller requires that the bluetooth disable_ertm parameter be set to true; to do this:","title":"bluetooth pairing"},{"location":"parts/controllers/#jetson-nano","text":"Adapted from: https://www.roboticsbuildlog.com/hardware/xbox-one-controller-with-nvidia-jetson-nano Install these python libraries before we disable ertm. sudo apt-get install nano Add Non-root access to your input folder: sudo usermod -a -G dialout $USER sudo reboot Install sysfsutils sudo apt-get install sysfsutils Edit the config to disable bluetooth ertm sudo nano /etc/sysfs.conf Append this to the end of the config /module/bluetooth/parameters/disable_ertm=1 Reboot your computer sudo reboot Re-pair the Xbox One Bluetooth Controller Unpair (forget) the controller first if you already tried to pair it, then pair it again. You can do this with the Bluetooth Manager GUI appliation that ships with Jetpack or if you are using command line, then use bluetoothctl: Open terminal and type: bluetoothctl then you should see the list of devices you have paired with and their corresponding MAC address. If you do not, type: paired-devices To un-pair a device type (replace aa:bb:cc:dd:ee:ff with the MAC address of the device to un-pair): remove aa:bb:cc:dd:ee:ff exit Pair your device using either Bluetooth Manager GUI or bluetoothctl (see RaspberryPi OS instruction starting with sudo bluetoothctl ) Once paired you should have a solid light on the xbox button and a stable bluetooth connection.","title":"Jetson Nano"},{"location":"parts/controllers/#raspberrypi-os","text":"edit the file /etc/modprobe.d/xbox_bt.conf (that may create the file; it is commonly not there by default) add the line: options bluetooth disable_ertm=1 reboot so that this takes affect. after reboot you can verify that disable_ertm is set to true entering this command in a terminal: bash cat /sys/module/bluetooth/parameters/disable_ertm the result should print 'Y'. If not, make sure the above steps have been done correctly. Once that is done, you can pair your controller to your Raspberry Pi using the bluetooth tool. Enter the following command into a bash shell prompt: sudo bluetoothctl That will start blue tooth pairing in interactive mode. The remaining commands will be entered in that interactive session. Enter the following commands: agent on default-agent scan on That last command will start the Raspberry Pi scanning for new bluetooth devices. At this point, turn on your XBox One controller using the big round 'X' button on top, then start the pairing mode by pressing the 'sync' button on the front of the controller. Within a few minutes, you should see the controller show up in the output something like this; [NEW] Device B8:27:EB:A4:59:08 XBox One Wireless Controller Write down the MAC address, you will need it for the following steps. Enter this command to pair with your controller: connect YOUR_MAC_ADDRESS where YOUR_MAC_ADDRESS is the MAC address you copied previously. If it does not connect on the first try, try again. It can take a few tries. If your controller connects, but then immediately disconnects, your disable_ertm setting might be wrong (see above). Once your controller is connected, the big round 'X' button on the top of your controller should be solid white. Enter the following commands to finish: trust YOUR_MAC_ADDRESS quit Now that your controller is trusted, it should automatically connect with your Raspberry Pi when they are both turned on. If your controller fails to connect, run the bluetoothctl steps again to reconnect.","title":"RaspberryPi OS"},{"location":"parts/controllers/#creating-a-new-or-custom-game-controller","text":"To discover or modify the button and axis mappings for your controller, you can use the Joystick Wizard . The Joystick Wizard will write a custom controller named 'my_joystick.py' to your mycar folder. To use the custom controller, set CONTROLLER_TYPE=\"custom\" in your myconfig.py.","title":"Creating a New or Custom Game Controller"},{"location":"parts/imu/","text":"IMU IMUs or inertial measurement units are parts that sense the inertial forces on a robot. They vary depending on sensor, but may commonly include linear and rotational accelleration. They may sometimes include magnetometer to give global compasss facing dir. Frequently temperature is available from these as it affects their sensitivity. MPU6050/MPU9250 This is a cheap, small, and moderately precise imu. Commonly available at Amazon . MPU9250 offers additional integrated magnetometer. Typically uses the I2C interface and can be chained off the default PWM PCA9685 board. This configuration will also provide power. MPU6050: Outputs acceleration X, Y, Z, Gyroscope X, Y, Z, and temperature. MPU6250: Outputs acceleration X, Y, Z, Gyroscope X, Y, Z, Magnetometer X, Y, Z and temperature. Chip built-in 16bit AD converter, 16bit data output Gyroscopes range: +/- 250 500 1000 2000 degree/sec Acceleration range: \u00b12 \u00b14 \u00b18 \u00b116g Software Setup Install smbus either from package: sudo apt install python3-smbus or from source: sudo apt-get install i2c-tools libi2c-dev python-dev python3-dev git clone https://github.com/pimoroni/py-smbus.git cd py-smbus/library python setup.py build sudo python setup.py install For MPU6050: Install pip lib for mpu6050 : pip install mpu6050-raspberrypi For MPU9250: Install pip lib for mpu9250-jmdev : pip install mpu9250-jmdev Configuration Enable the following configurations to your myconfig.py : #IMU HAVE_IMU = True IMU_SENSOR = 'mpu9250' # (mpu6050|mpu9250) IMU_DLP_CONFIG = 3 IMU_SENSOR can be either mpu6050 or mpu9250 based on the sensor you are using. IMU_DLP_CONFIG allows to change the digital lowpass filter settings for your IMU. Lower frequency settings (see below) can filter high frequency noise at the expense of increased latency in IMU sensor data. Valid settings are from 0 to 6: 0 250Hz 1 184Hz 2 92Hz 3 41Hz 4 20Hz 5 10Hz 6 5Hz Notes on MPU9250 At startup the MPU9250 driver performs calibration to zero accel and gyro bias. Usually the process takes less than 10 seconds, and in that time avoid moving or touching the car. Please place the car on the ground before starting Donkey.","title":"IMU"},{"location":"parts/imu/#imu","text":"IMUs or inertial measurement units are parts that sense the inertial forces on a robot. They vary depending on sensor, but may commonly include linear and rotational accelleration. They may sometimes include magnetometer to give global compasss facing dir. Frequently temperature is available from these as it affects their sensitivity.","title":"IMU"},{"location":"parts/imu/#mpu6050mpu9250","text":"This is a cheap, small, and moderately precise imu. Commonly available at Amazon . MPU9250 offers additional integrated magnetometer. Typically uses the I2C interface and can be chained off the default PWM PCA9685 board. This configuration will also provide power. MPU6050: Outputs acceleration X, Y, Z, Gyroscope X, Y, Z, and temperature. MPU6250: Outputs acceleration X, Y, Z, Gyroscope X, Y, Z, Magnetometer X, Y, Z and temperature. Chip built-in 16bit AD converter, 16bit data output Gyroscopes range: +/- 250 500 1000 2000 degree/sec Acceleration range: \u00b12 \u00b14 \u00b18 \u00b116g","title":"MPU6050/MPU9250"},{"location":"parts/imu/#software-setup","text":"Install smbus either from package: sudo apt install python3-smbus or from source: sudo apt-get install i2c-tools libi2c-dev python-dev python3-dev git clone https://github.com/pimoroni/py-smbus.git cd py-smbus/library python setup.py build sudo python setup.py install For MPU6050: Install pip lib for mpu6050 : pip install mpu6050-raspberrypi For MPU9250: Install pip lib for mpu9250-jmdev : pip install mpu9250-jmdev","title":"Software Setup"},{"location":"parts/imu/#configuration","text":"Enable the following configurations to your myconfig.py : #IMU HAVE_IMU = True IMU_SENSOR = 'mpu9250' # (mpu6050|mpu9250) IMU_DLP_CONFIG = 3 IMU_SENSOR can be either mpu6050 or mpu9250 based on the sensor you are using. IMU_DLP_CONFIG allows to change the digital lowpass filter settings for your IMU. Lower frequency settings (see below) can filter high frequency noise at the expense of increased latency in IMU sensor data. Valid settings are from 0 to 6: 0 250Hz 1 184Hz 2 92Hz 3 41Hz 4 20Hz 5 10Hz 6 5Hz","title":"Configuration"},{"location":"parts/imu/#notes-on-mpu9250","text":"At startup the MPU9250 driver performs calibration to zero accel and gyro bias. Usually the process takes less than 10 seconds, and in that time avoid moving or touching the car. Please place the car on the ground before starting Donkey.","title":"Notes on MPU9250"},{"location":"parts/keras/","text":"Keras Parts These parts encapsulate models defined using the Keras high level api. They are intended to be used with the Tensorflow backend. The parts are designed to use the trained artificial neural network to reproduce the steering and throttle given the image the camera sees. They are created by using the train command . Keras Categorical This model type is created with the --type=categorical . The KerasCategorical pilot breaks the steering and throttle decisions into discreet angles and then uses categorical cross entropy to train the network to activate a single neuron for each steering and throttle choice. This can be interesting because we get the confidence value as a distribution over all choices. This uses the dk.utils.linear_bin and dk.utils.linear_unbin to transform continuous real numbers into a range of discreet values for training and runtime. The input and output are therefore bounded and must be chosen wisely to match the data. The default ranges work for the default setup. But cars which go faster may want to enable a higher throttle range. And cars with larger steering throw may want more bins. This model was the original model, with some modifications, when Donkey was first created. Pros It has some benefits of showing the confidense as a distribution via the makemovie command. It has been very robust. In some cases this model has learned thottle control better than other models. Performs well in a limited compute environment like the Pi3. Cons Suffers from some arbitrary limitations of the chosen limits for number of categories, and thottle upper limit. Model Summary Input: Image Network: 5 Convolution layers followed by two dense layers before output Output: Two dense layers, 16, and 20 w categorical output Keras Linear This model type is created with the --type=linear . The KerasLinear pilot uses one neuron to output a continous value via the Keras Dense layer with linear activation. One each for steering and throttle. The output is not bounded. Pros Steers smoothly. It has been very robust. Performs well in a limited compute environment like the Pi3. No arbitrary limits to steering or throttle. Cons May sometimes fail to learn throttle well. Model Summary Input: Image Network: 5 Convolution layers followed by two dense layers before output Output: Two dense layers with one scalar output each with linear activation for steering and throttle. Keras IMU This model type is created with the --type=imu . The KerasIMU pilot is very similar to the KerasLinear model, except that it takes intertial measurment data in addition to images when learning to drive. This gives our stateless model some additional information about the motion of the vehicle. This can be a good starting point example of ingesting more data into your models. Pros Steers very smoothly. Performs well in a limited compute environment like the Pi3. No arbitrary limits to steering or throttle. Gives additional state to the model, which might help it come to a stop at a stop sign. Cons Driving quality will suffer if noisy imu is used. Model Summary Input: Image, vector of linear and angular acceleration Network: 5 Convolution layers followed by two dense layers before output, Vector data is followed by 3 dense layers then concatenating before 2 dense control layers and after conv2d layers. Output: Two dense layers with one scalar output each with linear activation for steering and throttle. Keras Latent This model type is created with the --type=latent . The KerasLatent pilot tries to force the model to learn a latent vector in addition to driving. This latent vector is a bottleneck in a CNN that then tries to reproduce the given input image and produce driving commands. These dual tasks could produce a model that learns to distill the driving scene and perhaps better abstract to a new track. Pros Steers smoothly. Performs well in a limited compute environment like the Pi3. No arbitrary limits to steering or throttle. Image output a measure of what the model has deemed important in the scene. Cons Needs more testing to prove theory. Model Summary Input: Image Network: 5 Convolution layers bottleneck to a 10x1x1 vector, followed by 6Conv2dTranspose layers before outputing to a image and 3 dense layers and driving controls. Output: Two dense layers with one scalar output each with linear activation for steering and throttle. Outputs an image. Keras RNN This model type is created with the --type=rnn . The KerasRNN pilot uses a sequence of images to control driving rather than just a single frame. The number of images used is controlled by the SEQUENCE_LENGTH value in myconfig.py. Pros Steers very smoothly. Can train to a lower loss Cons Performs worse in a limited compute environment like the Pi3. Takes longer to train. Model Summary Input: Image Network: 4 time distributed Convolution layers, followed by 2 LSTM layers, 3 dense layers, and driving controls. Output: One dense layer with two scalar outputs for steering and throttle. Keras 3D This model type is created with the --type=3d . The Keras3D_CNN pilot uses a sequence of images to control driving rather than just a single frame. The number of images used is controlled by the SEQUENCE_LENGTH value in myconfig.py. Instead of 2d convolutions like most other models, this uses a 3D convolution across layers. Pros Steers very smoothly. Can train to a lower loss. Cons Performs worse in a limited compute environment like the Pi3. Takes longer to train. Model Summary Input: Image Network: 4 3D Convolution layers each followed by max pooling, followed by 2 dense layers, and driving controls. Output: One dense layer with two scalar outputs for steering and throttle. Keras Behavior This model type is created with the --type=behavior . The KerasBehavioral pilot takes an image and a vector as input. The vector is one hot activated vector of commands. This vector might be of length two and have two states, one for left lane driving and one for right lane driving. Then during training one element of the vector is activated while the desired behavior is demonstrated. This vector is defined in myconfig.py BEHAVIOR_LIST . BEHAVIOR_LED_COLORS must match the same length and can be useful when showing the current state. TRAIN_BEHAVIORS must be set to True. Pros Can create a model which can perform multiple tasks Cons Takes more effort to train. Model Summary Input: Image, Behavior vector Network: 5 Convolution layers, followed by 2 dense layers, and driving controls. Output: Categorical steering, throttle output similar to Categorical keras model. Keras Localizer This model type is not created without some code modification. The KerasLocalizer pilot is very similar to the Keras Linear model, except that it learns to output it's location as a category. This category is arbitrary, but has only been tested as a 0-9 range segment of the track. This requires that the driving data is marked up with a category label for location. This could supply some higher level logic with track location, for driving stategy, lap counting, or other. Pros Steers smoothly. Performs well in a limited compute environment like the Pi3. No arbitrary limits to steering or throttle. Location to supply some higher level logic. Cons May sometimes fail to learn throttle well. Model Summary Input: Image Network: 5 Convolution layers followed by two dense layers before output Output: Two dense layers with one scalar output each with linear activation for steering and throttle. One categorical output for location.","title":"Keras Parts"},{"location":"parts/keras/#keras-parts","text":"These parts encapsulate models defined using the Keras high level api. They are intended to be used with the Tensorflow backend. The parts are designed to use the trained artificial neural network to reproduce the steering and throttle given the image the camera sees. They are created by using the train command .","title":"Keras Parts"},{"location":"parts/keras/#keras-categorical","text":"This model type is created with the --type=categorical . The KerasCategorical pilot breaks the steering and throttle decisions into discreet angles and then uses categorical cross entropy to train the network to activate a single neuron for each steering and throttle choice. This can be interesting because we get the confidence value as a distribution over all choices. This uses the dk.utils.linear_bin and dk.utils.linear_unbin to transform continuous real numbers into a range of discreet values for training and runtime. The input and output are therefore bounded and must be chosen wisely to match the data. The default ranges work for the default setup. But cars which go faster may want to enable a higher throttle range. And cars with larger steering throw may want more bins. This model was the original model, with some modifications, when Donkey was first created.","title":"Keras Categorical"},{"location":"parts/keras/#pros","text":"It has some benefits of showing the confidense as a distribution via the makemovie command. It has been very robust. In some cases this model has learned thottle control better than other models. Performs well in a limited compute environment like the Pi3.","title":"Pros"},{"location":"parts/keras/#cons","text":"Suffers from some arbitrary limitations of the chosen limits for number of categories, and thottle upper limit.","title":"Cons"},{"location":"parts/keras/#model-summary","text":"Input: Image Network: 5 Convolution layers followed by two dense layers before output Output: Two dense layers, 16, and 20 w categorical output","title":"Model Summary"},{"location":"parts/keras/#keras-linear","text":"This model type is created with the --type=linear . The KerasLinear pilot uses one neuron to output a continous value via the Keras Dense layer with linear activation. One each for steering and throttle. The output is not bounded.","title":"Keras Linear"},{"location":"parts/keras/#pros_1","text":"Steers smoothly. It has been very robust. Performs well in a limited compute environment like the Pi3. No arbitrary limits to steering or throttle.","title":"Pros"},{"location":"parts/keras/#cons_1","text":"May sometimes fail to learn throttle well.","title":"Cons"},{"location":"parts/keras/#model-summary_1","text":"Input: Image Network: 5 Convolution layers followed by two dense layers before output Output: Two dense layers with one scalar output each with linear activation for steering and throttle.","title":"Model Summary"},{"location":"parts/keras/#keras-imu","text":"This model type is created with the --type=imu . The KerasIMU pilot is very similar to the KerasLinear model, except that it takes intertial measurment data in addition to images when learning to drive. This gives our stateless model some additional information about the motion of the vehicle. This can be a good starting point example of ingesting more data into your models.","title":"Keras IMU"},{"location":"parts/keras/#pros_2","text":"Steers very smoothly. Performs well in a limited compute environment like the Pi3. No arbitrary limits to steering or throttle. Gives additional state to the model, which might help it come to a stop at a stop sign.","title":"Pros"},{"location":"parts/keras/#cons_2","text":"Driving quality will suffer if noisy imu is used.","title":"Cons"},{"location":"parts/keras/#model-summary_2","text":"Input: Image, vector of linear and angular acceleration Network: 5 Convolution layers followed by two dense layers before output, Vector data is followed by 3 dense layers then concatenating before 2 dense control layers and after conv2d layers. Output: Two dense layers with one scalar output each with linear activation for steering and throttle.","title":"Model Summary"},{"location":"parts/keras/#keras-latent","text":"This model type is created with the --type=latent . The KerasLatent pilot tries to force the model to learn a latent vector in addition to driving. This latent vector is a bottleneck in a CNN that then tries to reproduce the given input image and produce driving commands. These dual tasks could produce a model that learns to distill the driving scene and perhaps better abstract to a new track.","title":"Keras Latent"},{"location":"parts/keras/#pros_3","text":"Steers smoothly. Performs well in a limited compute environment like the Pi3. No arbitrary limits to steering or throttle. Image output a measure of what the model has deemed important in the scene.","title":"Pros"},{"location":"parts/keras/#cons_3","text":"Needs more testing to prove theory.","title":"Cons"},{"location":"parts/keras/#model-summary_3","text":"Input: Image Network: 5 Convolution layers bottleneck to a 10x1x1 vector, followed by 6Conv2dTranspose layers before outputing to a image and 3 dense layers and driving controls. Output: Two dense layers with one scalar output each with linear activation for steering and throttle. Outputs an image.","title":"Model Summary"},{"location":"parts/keras/#keras-rnn","text":"This model type is created with the --type=rnn . The KerasRNN pilot uses a sequence of images to control driving rather than just a single frame. The number of images used is controlled by the SEQUENCE_LENGTH value in myconfig.py.","title":"Keras RNN"},{"location":"parts/keras/#pros_4","text":"Steers very smoothly. Can train to a lower loss","title":"Pros"},{"location":"parts/keras/#cons_4","text":"Performs worse in a limited compute environment like the Pi3. Takes longer to train.","title":"Cons"},{"location":"parts/keras/#model-summary_4","text":"Input: Image Network: 4 time distributed Convolution layers, followed by 2 LSTM layers, 3 dense layers, and driving controls. Output: One dense layer with two scalar outputs for steering and throttle.","title":"Model Summary"},{"location":"parts/keras/#keras-3d","text":"This model type is created with the --type=3d . The Keras3D_CNN pilot uses a sequence of images to control driving rather than just a single frame. The number of images used is controlled by the SEQUENCE_LENGTH value in myconfig.py. Instead of 2d convolutions like most other models, this uses a 3D convolution across layers.","title":"Keras 3D"},{"location":"parts/keras/#pros_5","text":"Steers very smoothly. Can train to a lower loss.","title":"Pros"},{"location":"parts/keras/#cons_5","text":"Performs worse in a limited compute environment like the Pi3. Takes longer to train.","title":"Cons"},{"location":"parts/keras/#model-summary_5","text":"Input: Image Network: 4 3D Convolution layers each followed by max pooling, followed by 2 dense layers, and driving controls. Output: One dense layer with two scalar outputs for steering and throttle.","title":"Model Summary"},{"location":"parts/keras/#keras-behavior","text":"This model type is created with the --type=behavior . The KerasBehavioral pilot takes an image and a vector as input. The vector is one hot activated vector of commands. This vector might be of length two and have two states, one for left lane driving and one for right lane driving. Then during training one element of the vector is activated while the desired behavior is demonstrated. This vector is defined in myconfig.py BEHAVIOR_LIST . BEHAVIOR_LED_COLORS must match the same length and can be useful when showing the current state. TRAIN_BEHAVIORS must be set to True.","title":"Keras Behavior"},{"location":"parts/keras/#pros_6","text":"Can create a model which can perform multiple tasks","title":"Pros"},{"location":"parts/keras/#cons_6","text":"Takes more effort to train.","title":"Cons"},{"location":"parts/keras/#model-summary_6","text":"Input: Image, Behavior vector Network: 5 Convolution layers, followed by 2 dense layers, and driving controls. Output: Categorical steering, throttle output similar to Categorical keras model.","title":"Model Summary"},{"location":"parts/keras/#keras-localizer","text":"This model type is not created without some code modification. The KerasLocalizer pilot is very similar to the Keras Linear model, except that it learns to output it's location as a category. This category is arbitrary, but has only been tested as a 0-9 range segment of the track. This requires that the driving data is marked up with a category label for location. This could supply some higher level logic with track location, for driving stategy, lap counting, or other.","title":"Keras Localizer"},{"location":"parts/keras/#pros_7","text":"Steers smoothly. Performs well in a limited compute environment like the Pi3. No arbitrary limits to steering or throttle. Location to supply some higher level logic.","title":"Pros"},{"location":"parts/keras/#cons_7","text":"May sometimes fail to learn throttle well.","title":"Cons"},{"location":"parts/keras/#model-summary_7","text":"Input: Image Network: 5 Convolution layers followed by two dense layers before output Output: Two dense layers with one scalar output each with linear activation for steering and throttle. One categorical output for location.","title":"Model Summary"},{"location":"parts/lidar/","text":"Lidar A Lidar sensor can be used with Donkeycar to provide obstacle avoidance or to help navigate on tracks with walls. It records data along with the camera during training and this can be used for training NOTE: Lidar is currently only supported in the Dev branch. To use it, after you git clone donkeycar, do a git checkout dev Supported Lidars We currently only support the RPLidar series of sensors, but will be adding support for the similar YDLidar series soon. We recommend the $99 A1M8 (12m range) Hardware Setup Mount the Lidar underneath the camera canopy as shown above (the RPLidar A2M8 is used there, but the A1M8 mounting is the same). You can velcro the USB adapter under the Donkey plate and use a short USB cable to connect to one of your RPi or Nano USB ports. It can be powered by the USB port so there's no need for an additional power supply. Software Setup Lidar requires the glob library to be installed. If you don't already have that, install it with pip3 install glob2 Also install the Lidar driver: pip install Adafruit_CircuitPython_RPLIDAR Then go to the lidarcar directory and edit the myconfig.py file to ensure that the Lidar is turned on. The upper and lower limits should be set to reflect the areas you want your Lidar to \"look at\", omitting the areas that are blocked by parts of the car body. An example is shown below. For the RPLidar series, 0 degrees is in the direction of the motor (in the case of the A1M8) or cable (in the case of the A2M8) # LIDAR USE_LIDAR = True LIDAR_TYPE = 'RP' #(RP|YD) LIDAR_LOWER_LIMIT = 90 # angles that will be recorded. Use this to block out obstructed areas on your car and/or to avoid looking backwards. Note that for the RP A1M8 Lidar, \"0\" is in the direction of the motor LIDAR_UPPER_LIMIT = 270","title":"Lidar"},{"location":"parts/lidar/#lidar","text":"A Lidar sensor can be used with Donkeycar to provide obstacle avoidance or to help navigate on tracks with walls. It records data along with the camera during training and this can be used for training NOTE: Lidar is currently only supported in the Dev branch. To use it, after you git clone donkeycar, do a git checkout dev","title":"Lidar"},{"location":"parts/lidar/#supported-lidars","text":"We currently only support the RPLidar series of sensors, but will be adding support for the similar YDLidar series soon. We recommend the $99 A1M8 (12m range)","title":"Supported Lidars"},{"location":"parts/lidar/#hardware-setup","text":"Mount the Lidar underneath the camera canopy as shown above (the RPLidar A2M8 is used there, but the A1M8 mounting is the same). You can velcro the USB adapter under the Donkey plate and use a short USB cable to connect to one of your RPi or Nano USB ports. It can be powered by the USB port so there's no need for an additional power supply.","title":"Hardware Setup"},{"location":"parts/lidar/#software-setup","text":"Lidar requires the glob library to be installed. If you don't already have that, install it with pip3 install glob2 Also install the Lidar driver: pip install Adafruit_CircuitPython_RPLIDAR Then go to the lidarcar directory and edit the myconfig.py file to ensure that the Lidar is turned on. The upper and lower limits should be set to reflect the areas you want your Lidar to \"look at\", omitting the areas that are blocked by parts of the car body. An example is shown below. For the RPLidar series, 0 degrees is in the direction of the motor (in the case of the A1M8) or cable (in the case of the A2M8) # LIDAR USE_LIDAR = True LIDAR_TYPE = 'RP' #(RP|YD) LIDAR_LOWER_LIMIT = 90 # angles that will be recorded. Use this to block out obstructed areas on your car and/or to avoid looking backwards. Note that for the RP A1M8 Lidar, \"0\" is in the direction of the motor LIDAR_UPPER_LIMIT = 270","title":"Software Setup"},{"location":"parts/odometry/","text":"Odometry Odometry is a way to calculate the speed and distance travelled of the car by measuring the rotation of its wheels using a sensor called an rotary encoder. This encoder can be on the motor, on the main drive shaft or on individual wheels. The advantage of using an encoder is that it \"closes the loop\" with your throttle, so your car can reliably command an actual velocity rather than just issuing a motor control which will produce a faster or slower velocity depending on the slope of the track, the surface or mechanical friction in your drive train while turning. In short, an encoder gives you much better control over your speed. Encoders come in various forms: * Quadrature encoders use hall-effect sensors to measure magnetic pulses as the shaft turns, and have the advantage of being very precise as well as being able to tell the difference between forward and reverse rotation * Single-output encoders are like quadrature encoders but they can not determine the direction of motion * Optical encoders are typicall a LED/Light sensor combo with a disk that has slots cut in in-between them. As the disk rotates, the light is interruprted and those pulses are counted. These sensors are cheap and easy to install but cannot determine the direction of rotation There are several ways to read encoders with Donkey: * Directly with the RaspberryPi's GPIO pins. This is best for optical encoders, since they don't generate as many pulses as a quadrature encoder and the RPi will miss fewer of them as it task-swaps between the various Donkeycar parts * With an Arduino or Teensy. This is best for quadrature encoders, since the Arduino/Teensy is 100% devoted to counting pulses. It transmits the count to the RPi via the USB serial port when requested by Donkeycar, which lightens the processing load for the Rpi * With an Astar board. This is just a fancy Arduino, but if you have one, it makes for a neat installation Supported Encoders Examples of rotary encoders that are supported: Optical encoder sensors and discs Available from many sources on Amazon Quadrature encoders. Larger, cheaper , Smaller, more expensive Hardware Setup How you attach your encoder is up to you and which kind of encoder you're using. For example, here's one way to put a quadrature encoder on the main drive shaft. Here is a more complex setup with dual encoders. But this is the easiest way to do it, with a cheap and simple optical encoder on the main drive shaft of a standard Donkeycar chassis (if your chassis is different, the same overall approach should work, although you may have to find a different place to mount the sensor): First, unscrew the plate over the main drive shaft. Tilt the rear wheels back a bit and you should be able to remove the shaft. Now enlarge the hole in the optical encoder disc that came with your sensor (use a drill or Dremel grinding stone) so you can slip it onto the shaft. Stretch a rubber grommet (you can use the sort typically included with servos to mount them, but any one of the right size will do) over the shaft and push it into the encoder disc hole. If you don't have a grommet, you can wrap tape around the shaft until it's large enough to hold the disc firmly. Once you've ensured it's in the right place, use a few drops of superglue or hot glue to hold it in place) Cut out a small notch (marked in pencil here) in the plate covering the drive shaft, so you can mount the encoder sensor there, ensuring that the disc can turn freely in the gap in front of the steering servo Now replace the plate and drill two holes so you can screw in the encoder sensor. Slide the disc along the shaft so that it doesn't bind on the sensor. Use three female-to-female jumper cables and connect the sensor to your RPi GPIO pins as follows. Connect the GND, V+ (which might say 5V or 3.3V) and data pin (which will say \"Out or \"D0\") to the RPi 5V, Ground and GPIO 13 as shown here (if your sensor encoder has four pins, ignore the one that says \"A0\"): Note: if you're already using GPIO 13 for another reason, such as RC input or output, you can use any other free GPIO pin. Just change the ODOM_PIN number accordingly in the myconfig.py file as shown below. Software Setup Enable odometry in myconfig.py . HAVE_ODOM = True # Do you have an odometer/encoder ENCODER_TYPE = 'GPIO' # What kind of encoder? GPIO|Arduino|Astar MM_PER_TICK = 12.7625 # How much travel with a single tick, in mm. Roll you car a meter and divide total ticks measured by 1,000 ODOM_PIN = 13 # if using GPIO, which GPIO board mode pin to use as input ODOM_DEBUG = False # Write out values on vel and distance as it runs If you are using an Arduino or Teensy to read your encoder, select 'Arduino' in the myconfig.py file libe above. The microcontroller should be flashed using the Arduino IDE with this sketch . Make sure you check the sketch using the \"test_encoder.py code in the Donkeycar tests folder to make sure you've got your encoder plugged into the right pins, or edit it to reflect the pins you are using.","title":"Odometry"},{"location":"parts/odometry/#odometry","text":"Odometry is a way to calculate the speed and distance travelled of the car by measuring the rotation of its wheels using a sensor called an rotary encoder. This encoder can be on the motor, on the main drive shaft or on individual wheels. The advantage of using an encoder is that it \"closes the loop\" with your throttle, so your car can reliably command an actual velocity rather than just issuing a motor control which will produce a faster or slower velocity depending on the slope of the track, the surface or mechanical friction in your drive train while turning. In short, an encoder gives you much better control over your speed. Encoders come in various forms: * Quadrature encoders use hall-effect sensors to measure magnetic pulses as the shaft turns, and have the advantage of being very precise as well as being able to tell the difference between forward and reverse rotation * Single-output encoders are like quadrature encoders but they can not determine the direction of motion * Optical encoders are typicall a LED/Light sensor combo with a disk that has slots cut in in-between them. As the disk rotates, the light is interruprted and those pulses are counted. These sensors are cheap and easy to install but cannot determine the direction of rotation There are several ways to read encoders with Donkey: * Directly with the RaspberryPi's GPIO pins. This is best for optical encoders, since they don't generate as many pulses as a quadrature encoder and the RPi will miss fewer of them as it task-swaps between the various Donkeycar parts * With an Arduino or Teensy. This is best for quadrature encoders, since the Arduino/Teensy is 100% devoted to counting pulses. It transmits the count to the RPi via the USB serial port when requested by Donkeycar, which lightens the processing load for the Rpi * With an Astar board. This is just a fancy Arduino, but if you have one, it makes for a neat installation","title":"Odometry"},{"location":"parts/odometry/#supported-encoders","text":"Examples of rotary encoders that are supported: Optical encoder sensors and discs Available from many sources on Amazon Quadrature encoders. Larger, cheaper , Smaller, more expensive","title":"Supported Encoders"},{"location":"parts/odometry/#hardware-setup","text":"How you attach your encoder is up to you and which kind of encoder you're using. For example, here's one way to put a quadrature encoder on the main drive shaft. Here is a more complex setup with dual encoders. But this is the easiest way to do it, with a cheap and simple optical encoder on the main drive shaft of a standard Donkeycar chassis (if your chassis is different, the same overall approach should work, although you may have to find a different place to mount the sensor): First, unscrew the plate over the main drive shaft. Tilt the rear wheels back a bit and you should be able to remove the shaft. Now enlarge the hole in the optical encoder disc that came with your sensor (use a drill or Dremel grinding stone) so you can slip it onto the shaft. Stretch a rubber grommet (you can use the sort typically included with servos to mount them, but any one of the right size will do) over the shaft and push it into the encoder disc hole. If you don't have a grommet, you can wrap tape around the shaft until it's large enough to hold the disc firmly. Once you've ensured it's in the right place, use a few drops of superglue or hot glue to hold it in place) Cut out a small notch (marked in pencil here) in the plate covering the drive shaft, so you can mount the encoder sensor there, ensuring that the disc can turn freely in the gap in front of the steering servo Now replace the plate and drill two holes so you can screw in the encoder sensor. Slide the disc along the shaft so that it doesn't bind on the sensor. Use three female-to-female jumper cables and connect the sensor to your RPi GPIO pins as follows. Connect the GND, V+ (which might say 5V or 3.3V) and data pin (which will say \"Out or \"D0\") to the RPi 5V, Ground and GPIO 13 as shown here (if your sensor encoder has four pins, ignore the one that says \"A0\"): Note: if you're already using GPIO 13 for another reason, such as RC input or output, you can use any other free GPIO pin. Just change the ODOM_PIN number accordingly in the myconfig.py file as shown below.","title":"Hardware Setup"},{"location":"parts/odometry/#software-setup","text":"Enable odometry in myconfig.py . HAVE_ODOM = True # Do you have an odometer/encoder ENCODER_TYPE = 'GPIO' # What kind of encoder? GPIO|Arduino|Astar MM_PER_TICK = 12.7625 # How much travel with a single tick, in mm. Roll you car a meter and divide total ticks measured by 1,000 ODOM_PIN = 13 # if using GPIO, which GPIO board mode pin to use as input ODOM_DEBUG = False # Write out values on vel and distance as it runs If you are using an Arduino or Teensy to read your encoder, select 'Arduino' in the myconfig.py file libe above. The microcontroller should be flashed using the Arduino IDE with this sketch . Make sure you check the sketch using the \"test_encoder.py code in the Donkeycar tests folder to make sure you've got your encoder plugged into the right pins, or edit it to reflect the pins you are using.","title":"Software Setup"},{"location":"parts/oled/","text":"OLED Displays OLED displays can be used to show information about the current state of the car. This is especially useful in the when collecting data for training, and when racing. The OLED display currently displays the following information: * The IP address of the car ( eth and wlan ) * The number of records collected, for training. * The driving mode. Supported displays Examples of displays that are currently supported are: Adafruit PiOLED - 128X32 MonoChrome OLED Hardware Setup Simply connect the display to the I2C pins on the Raspberry Pi or the Jetson Nano. Use bus 1 so the display can be inserted directly on the pins. Here is an example of what that looks like. Software Setup Enable the display in myconfig.py . If you have a 128x32 OLED select resolution 1, if you have 128x64 select resolution 2 # SSD1306_128_32 USE_SSD1306_128_32 = True # Enable the SSD_1306 OLED Display SSD1306_128_32_I2C_BUSNUM = 1 # I2C bus number SSD1306_RESOLUTION = 1 # 1 = 128x32; 2 = 128x64 Showing your IP address on startup. One of the cool things about having an OLED screen is that you can show your car's IP address on startup, so you can connect to it. Instructions to set that up are here Troubleshooting If you are unable to start the car, ensure that the Adafruit_SSD1306 package is installed in your virtual environment. This should automatically be installed, if you are using a recent version of donkeycar . pip install Adafruit_SSD1306 Known Issues The Adafruit_SSD1306 library is incompatible with steering/motor configurations when the Duty Cycle/PWM is supplied directly from GPIO header using the RPI_GPIO pin provider. This is because internally the Adafruit library sets a GPIO pin mode that is incompatible with our GPIO library. In this case you have a couple of options: Use a PCA9685 to generate the necessary duty cycle/PWM for throttle and steering. Use the PIGPIO pin provider to generate the necessary duty cycle/PWM for throttle and steering from the GPIO. See PIGPIO for how to set up the pigpio library.","title":"OLED Displays"},{"location":"parts/oled/#oled-displays","text":"OLED displays can be used to show information about the current state of the car. This is especially useful in the when collecting data for training, and when racing. The OLED display currently displays the following information: * The IP address of the car ( eth and wlan ) * The number of records collected, for training. * The driving mode.","title":"OLED Displays"},{"location":"parts/oled/#supported-displays","text":"Examples of displays that are currently supported are: Adafruit PiOLED - 128X32 MonoChrome OLED","title":"Supported displays"},{"location":"parts/oled/#hardware-setup","text":"Simply connect the display to the I2C pins on the Raspberry Pi or the Jetson Nano. Use bus 1 so the display can be inserted directly on the pins. Here is an example of what that looks like.","title":"Hardware Setup"},{"location":"parts/oled/#software-setup","text":"Enable the display in myconfig.py . If you have a 128x32 OLED select resolution 1, if you have 128x64 select resolution 2 # SSD1306_128_32 USE_SSD1306_128_32 = True # Enable the SSD_1306 OLED Display SSD1306_128_32_I2C_BUSNUM = 1 # I2C bus number SSD1306_RESOLUTION = 1 # 1 = 128x32; 2 = 128x64","title":"Software Setup"},{"location":"parts/oled/#showing-your-ip-address-on-startup","text":"One of the cool things about having an OLED screen is that you can show your car's IP address on startup, so you can connect to it. Instructions to set that up are here","title":"Showing your IP address on startup."},{"location":"parts/oled/#troubleshooting","text":"If you are unable to start the car, ensure that the Adafruit_SSD1306 package is installed in your virtual environment. This should automatically be installed, if you are using a recent version of donkeycar . pip install Adafruit_SSD1306","title":"Troubleshooting"},{"location":"parts/oled/#known-issues","text":"The Adafruit_SSD1306 library is incompatible with steering/motor configurations when the Duty Cycle/PWM is supplied directly from GPIO header using the RPI_GPIO pin provider. This is because internally the Adafruit library sets a GPIO pin mode that is incompatible with our GPIO library. In this case you have a couple of options: Use a PCA9685 to generate the necessary duty cycle/PWM for throttle and steering. Use the PIGPIO pin provider to generate the necessary duty cycle/PWM for throttle and steering from the GPIO. See PIGPIO for how to set up the pigpio library.","title":"Known Issues"},{"location":"parts/path_following/","text":"Path Following with the Intel Realsense T265 sensor Rather than using a standard camera and training a network to drive, Donkeycar supports using the Intel Realsense T265 \"tracking camera\" to follow a path instead. In this application, you simply drive a path once manually, and Donkeycar will \"remember\" that path and repeat it autonomously. The Intel T265 uses a combination of stereo cameras and an internal Inertial Measurement Unit (IMU) plus its own Myriad X processor to do Visual Inertial Odometry, which is a fancy way of saying that it knows where it is by looking at the scene around it as it moves and correlating that with the IMU's sensing to localize itself, outputting an X,Y,Z position to Donkey, much as a GPS sensor would (but ideally much more accurately, to a precision of centemeters) Note Although the Realsense T265 can be used with a Nvidia Jetson Nano, it's a bit easier to set up with a Raspberry Pi (we recommend the RPi 4, with at least 4GB memory). Also, the Intel Realsense D4XX series can also be used with Donkeycar as a regular camera (with the use of its depth sensing data coming soon), and we'll add instructions for that when it's ready. Original T265 path follower code by Tawn Kramer Step 1: Setup Librealsense on Ubuntu Machine Using the latest version of Raspian (tested with Raspian Buster) on the RPi, follow these instructions to set up Intel's Realsense libraries (Librealsense) and dependencies. Although those instructions discuss another Realsense sensor, they work equally well for the T265. There are also video instructions Step 2: Setup Donkeycar Follow the standard instructions here . With the Path Follower, there is no need to install Tensorflow for this particular Donkeycar configuration however do install numpy/upgrade before running \"pip install -e .[pi]\" Step 3: Create the Donkeycar path follower app ```donkey createcar --path ~/follow --template path_follow Step 4: Check/change your config settings cd ~follow sudo nano myconfig.py Make sure you agree with the default values or adjust them to your liking (ie. \"throttle\", \"steering\", PIDs, etc.). Uncomment (remove the #) for any line you've changed. In Nano press cntrl-o to save the file and cntrl-x to exit. Step 5: Run the Donkeycar path follower app Running ssh pi@<your pi\u2019s IP address or \"raspberrypi.local\"> cd ~/follow python3 manage.py drive Keep the terminal open to see the printed output of the app while it is running. If you get an error saying that it can't find the T265, unplug the sensor, plug it back in and try again. Ensure that your gamepad is on and connected, too (blue light is on the controller) Once it\u2019s running, open a browser on your laptop and enter this in the URL bar: http:// :8890 When you drive, the Web interface will draw a red line for the path, a green circle for the robot location. If you're seeing the green dot but not the red line, that means that a path file has already been written. Delete \u201cdonkey_path.pkl\u201d (rm donkey_path.pkl), restart and the red line should show up PS4 Gamepad controls are as follows: +------------------+--------------------------+ | control | action | +------------------+--------------------------+ | share | toggle auto/manual mode | | circle | save_path | | triangle | erase_path | | cross | emergency_stop | | L1 | increase_max_throttle | | R1 | decrease_max_throttle | | options | toggle_constant_throttle | | square | reset_origin | | L2 | dec_pid_d | | R2 | inc_pid_d | | left_stick_horz | set_steering | | right_stick_vert | set_throttle | +------------------+--------------------------+ Step 6: Driving instructions 1) Mark a nice starting spot for your robot. Be sure to put it right back there each time you start. 2) Drive the car in some kind of loop. You see the red line show the path. 3) Hit circle on the PS3/4 controller to save the path. 4) Put the bot back at the start spot. 5) Then hit the \u201cselect\u201d button (on a PS3 controller) or \u201cshare\u201d (on a PS4 controller) twice to go to pilot mode. This will start driving on the path. If you want it go faster or slower, change this line in the myconfig.py file: THROTTLE_FORWARD_PWM = 400 Check the bottom of myconfig.py for some settings to tweak. PID values, map offsets and scale. things like that. You might want to start by downloading and using the myconfig.py file from my repo, which has some known-good settings and is otherwise a good place to start. Some tips: When you start, the green dot will be in the top left corner of the box. You may prefer to have it in the center. If so, change PATH_OFFSET = (0, 0) in the myconfig.py file to PATH_OFFSET = (250, 250) For a small course, you may find that the path is too small to see well. In that case, change PATH_SCALE = 5.0 to PATH_SCALE = 10.0 (or more, if necessary) When you're running in auto mode, the green dot will change to blue It defaults to recording a path point every 0.3 meters. If you want it to be smoother, you can change to a smaller number in myconfig.py with this line: PATH_MIN_DIST = 0.3","title":"Path Following with the Intel Realsense T265 sensor"},{"location":"parts/path_following/#path-following-with-the-intel-realsense-t265-sensor","text":"Rather than using a standard camera and training a network to drive, Donkeycar supports using the Intel Realsense T265 \"tracking camera\" to follow a path instead. In this application, you simply drive a path once manually, and Donkeycar will \"remember\" that path and repeat it autonomously. The Intel T265 uses a combination of stereo cameras and an internal Inertial Measurement Unit (IMU) plus its own Myriad X processor to do Visual Inertial Odometry, which is a fancy way of saying that it knows where it is by looking at the scene around it as it moves and correlating that with the IMU's sensing to localize itself, outputting an X,Y,Z position to Donkey, much as a GPS sensor would (but ideally much more accurately, to a precision of centemeters) Note Although the Realsense T265 can be used with a Nvidia Jetson Nano, it's a bit easier to set up with a Raspberry Pi (we recommend the RPi 4, with at least 4GB memory). Also, the Intel Realsense D4XX series can also be used with Donkeycar as a regular camera (with the use of its depth sensing data coming soon), and we'll add instructions for that when it's ready.","title":"Path Following with the Intel Realsense T265 sensor"},{"location":"parts/path_following/#original-t265-path-follower-code-by-tawn-kramer","text":"","title":"Original T265 path follower code by Tawn Kramer"},{"location":"parts/path_following/#step-1-setup-librealsense-on-ubuntu-machine","text":"Using the latest version of Raspian (tested with Raspian Buster) on the RPi, follow these instructions to set up Intel's Realsense libraries (Librealsense) and dependencies. Although those instructions discuss another Realsense sensor, they work equally well for the T265. There are also video instructions","title":"Step 1: Setup Librealsense on Ubuntu Machine"},{"location":"parts/path_following/#step-2-setup-donkeycar","text":"Follow the standard instructions here . With the Path Follower, there is no need to install Tensorflow for this particular Donkeycar configuration however do install numpy/upgrade before running \"pip install -e .[pi]\"","title":"Step 2: Setup Donkeycar"},{"location":"parts/path_following/#step-3-create-the-donkeycar-path-follower-app","text":"```donkey createcar --path ~/follow --template path_follow","title":"Step 3: Create the Donkeycar path follower app"},{"location":"parts/path_following/#step-4-checkchange-your-config-settings","text":"cd ~follow sudo nano myconfig.py Make sure you agree with the default values or adjust them to your liking (ie. \"throttle\", \"steering\", PIDs, etc.). Uncomment (remove the #) for any line you've changed. In Nano press cntrl-o to save the file and cntrl-x to exit.","title":"Step 4: Check/change your config settings"},{"location":"parts/path_following/#step-5-run-the-donkeycar-path-follower-app","text":"Running ssh pi@<your pi\u2019s IP address or \"raspberrypi.local\"> cd ~/follow python3 manage.py drive Keep the terminal open to see the printed output of the app while it is running. If you get an error saying that it can't find the T265, unplug the sensor, plug it back in and try again. Ensure that your gamepad is on and connected, too (blue light is on the controller) Once it\u2019s running, open a browser on your laptop and enter this in the URL bar: http:// :8890 When you drive, the Web interface will draw a red line for the path, a green circle for the robot location. If you're seeing the green dot but not the red line, that means that a path file has already been written. Delete \u201cdonkey_path.pkl\u201d (rm donkey_path.pkl), restart and the red line should show up PS4 Gamepad controls are as follows: +------------------+--------------------------+ | control | action | +------------------+--------------------------+ | share | toggle auto/manual mode | | circle | save_path | | triangle | erase_path | | cross | emergency_stop | | L1 | increase_max_throttle | | R1 | decrease_max_throttle | | options | toggle_constant_throttle | | square | reset_origin | | L2 | dec_pid_d | | R2 | inc_pid_d | | left_stick_horz | set_steering | | right_stick_vert | set_throttle | +------------------+--------------------------+","title":"Step 5: Run the Donkeycar path follower app"},{"location":"parts/path_following/#step-6-driving-instructions","text":"1) Mark a nice starting spot for your robot. Be sure to put it right back there each time you start. 2) Drive the car in some kind of loop. You see the red line show the path. 3) Hit circle on the PS3/4 controller to save the path. 4) Put the bot back at the start spot. 5) Then hit the \u201cselect\u201d button (on a PS3 controller) or \u201cshare\u201d (on a PS4 controller) twice to go to pilot mode. This will start driving on the path. If you want it go faster or slower, change this line in the myconfig.py file: THROTTLE_FORWARD_PWM = 400 Check the bottom of myconfig.py for some settings to tweak. PID values, map offsets and scale. things like that. You might want to start by downloading and using the myconfig.py file from my repo, which has some known-good settings and is otherwise a good place to start. Some tips: When you start, the green dot will be in the top left corner of the box. You may prefer to have it in the center. If so, change PATH_OFFSET = (0, 0) in the myconfig.py file to PATH_OFFSET = (250, 250) For a small course, you may find that the path is too small to see well. In that case, change PATH_SCALE = 5.0 to PATH_SCALE = 10.0 (or more, if necessary) When you're running in auto mode, the green dot will change to blue It defaults to recording a path point every 0.3 meters. If you want it to be smoother, you can change to a smaller number in myconfig.py with this line: PATH_MIN_DIST = 0.3","title":"Step 6: Driving instructions"},{"location":"parts/pins/","text":"Pin Specifiers Control signals are send and received by pins on the Raspberry Pi, Jetson Nano and connected peripherals, like the PCA9685 Servo controller. Starting wit version 5.x, Donkeycar uses 'pin specs' to specify pins including various configuration that is specific to the underlying hardware or library implementation. This allows use to make the underlying logic, like how a motor controller takes throttle values and outputs them to the motor, more independent of the particular hardware or library used to generate the signals. Types of Pins PWM pins generate a square wave, sometimes called a PWM pulse. This is used to control servo motors, electronic speed controllers, and LEDs. TTL Output pins can generate either a high value (1) or a low value (0) TTL Input pins read values as either high (1) or low (0) Pin Providers Donkeycar supports several technologies for specifying pins. Pins are specified as a string that identifies the provider, the pin number and any techology specific configuration. PCA9685 The PCA9685 Servo controller supports 16 PWM and TTL output pins. The PCA9685 can only output signals; it does not support input pins. The pin specifier for a PCA9685 pin includes: the I2C bus to which the PCA9685 is attached the address in hex of the PCA9685 on the I2C bus the channel number 0.15 For example, \"PCA9685.1:40.13\" specifies channel 13 on the PCA9685 on I2C bus 1 at address 0x40. For example, \"PCA9685.0:60.1\" specified channel 1 on the PCA9685 on I2C bus 0 at address 0x60 RPI_GPIO Donkeycar installs the RPi.GPIO library on the RaspberryPi in the default installation. The Jetson.GPIO library is compatible library installed by default on the Jetson Nano. Both of these libaries work is a similar fashion to support PWM, input and output pins on the 40 pin GPIO bus of the RaspberryPi or Jetson Nano respectively. The pin specifier includes: The pin addressing scheme \"BOARD\" indicates the pin number is based on the pin numbers, 0 to 39, printed on the RaspberryPi/Jetson Nano circuit board. \"BCM\" indicates the pin number is based on the Broadcom GPIO number scheme implemented in the RaspberryPi. This scheme is emulated in the Jetson library, so \"BCM\" pin numbers can be used on the Jetson. The pin number, which depends upon the pin addressing scheme. See details of the RaspberryPi 40 pin header here: https://www.raspberrypi.com/documentation/computers/os.html#gpio-and-the-40-pin-header Jetson Nano 40 pin header uses the same board numbering scheme, although the header is physically flipped on the board, so pay attention to the numbers printed on the board. The Jetson Nano only supports 2 PWM pins and these must be enabled. See Generating PWM from the Jetson Nano For example, \"RPI_GPIO.BOARD.33\" specifies board pin 33 using the Rpi.GPIO library. For example, \"RPI_GPIO.BCM.13\" specifies Broadcom GPIO-13 using the Rpi.GPIO library. If you look at the header diagram linked above you will notice that this is the same physical pin as \"RPI_GPIO.BOARD.33\"; it is a synonymn for physical pin 33. When using the RPI_GPIO pin provider, you can choose to use the BOARD or BCM pin schemes, but all pins must use the same pin scheme. You cannot mix pin schemes. PIGPIO RaspberryPi users can optionally install the PiGPIO library and daemon to manage the pins on the 40 pin GPIO header. Note that this library does NOT work on the Jetson Nano. The library support PWM, Input and Output pins. Installing and Starting PiGPIO Install the system daemon sudo apt-get update sudo apt-get install pigpio Install python support (with donkey environment activated) pip install pigpio Start the daemon sudo systemctl start pigpiod Enable the daemon on startup sudo systemctl enable pigpiod The PIGPIO pin specifier includes: - \"BCM\" PiGPIO used Broadcom (BCM) pin numbering scheme exclusively, so that is baked into the pin specifier. - The BCM pin number For example, \"PIGPIO.BCM.13\" specifies Broadcom GPIO-13. As discussed above and shown in the linked header diagram, this is exposed on board pin 33. Generating PWM from the Jetson Nano Both the Jetson Nano and RaspberryPi4 support two hardware PWM pins. On the Jetson Nano, these must be configured. Configure Jetson Expansion Header for PWM ssh into the donkeycar and run this command sudo /opt/nvidia/jetson-io/jetson-io.py . It should show the Jetson Expansion Header Tool that allows you to change GPIO pin functions (see below). If your Jetson expansion header configuration does not show any PWM pins, then you will need to enable them. --- =================== Jetson Expansion Header Tool =================== | | | | | 3.3V ( 1) ( 2) 5V | | i2c2 ( 3) ( 4) 5V | | i2c2 ( 5) ( 6) GND | | unused ( 7) ( 8) uartb | | GND ( 9) (10) uartb | | unused (11) (12) unused | | unused (13) (14) GND | | unused (15) (16) unused | | 3.3V (17) (18) unused | | unused (19) (20) GND | | unused (21) (22) unused | | unused (23) (24) unused | | GND (25) (26) unused | | i2c1 (27) (28) i2c1 | | unused (29) (30) GND | | unused (31) (32) unused | | unused (33) (34) GND | | unused (35) (36) unused | | unused (37) (38) unused | | GND (39) (40) unused | | | ==================================================================== --- Choose Configure the 40 pin expansion header to activate pwm0 and pwm2: --- =================== Jetson Expansion Header Tool =================== | | | | | 3.3V ( 1) ( 2) 5V | | i2c2 ( 3) ( 4) 5V | | i2c2 ( 5) ( 6) GND | | unused ( 7) ( 8) uartb | | GND ( 9) (10) uartb | | unused (11) (12) unused | | unused (13) (14) GND | | unused (15) (16) unused | | 3.3V (17) (18) unused | | unused (19) (20) GND | | unused (21) (22) unused | | unused (23) (24) unused | | GND (25) (26) unused | | i2c1 (27) (28) i2c1 | | unused (29) (30) GND | | unused (31) (32) pwm0 | | pwm2 (33) (34) GND | | unused (35) (36) unused | | unused (37) (38) unused | | GND (39) (40) unused | | | ==================================================================== --- After enabling, pwm0 is board pin-32 and pwm2 is board pin-33.","title":"Pin Specifiers"},{"location":"parts/pins/#pin-specifiers","text":"Control signals are send and received by pins on the Raspberry Pi, Jetson Nano and connected peripherals, like the PCA9685 Servo controller. Starting wit version 5.x, Donkeycar uses 'pin specs' to specify pins including various configuration that is specific to the underlying hardware or library implementation. This allows use to make the underlying logic, like how a motor controller takes throttle values and outputs them to the motor, more independent of the particular hardware or library used to generate the signals.","title":"Pin Specifiers"},{"location":"parts/pins/#types-of-pins","text":"PWM pins generate a square wave, sometimes called a PWM pulse. This is used to control servo motors, electronic speed controllers, and LEDs. TTL Output pins can generate either a high value (1) or a low value (0) TTL Input pins read values as either high (1) or low (0)","title":"Types of Pins"},{"location":"parts/pins/#pin-providers","text":"Donkeycar supports several technologies for specifying pins. Pins are specified as a string that identifies the provider, the pin number and any techology specific configuration.","title":"Pin Providers"},{"location":"parts/pins/#pca9685","text":"The PCA9685 Servo controller supports 16 PWM and TTL output pins. The PCA9685 can only output signals; it does not support input pins. The pin specifier for a PCA9685 pin includes: the I2C bus to which the PCA9685 is attached the address in hex of the PCA9685 on the I2C bus the channel number 0.15 For example, \"PCA9685.1:40.13\" specifies channel 13 on the PCA9685 on I2C bus 1 at address 0x40. For example, \"PCA9685.0:60.1\" specified channel 1 on the PCA9685 on I2C bus 0 at address 0x60","title":"PCA9685"},{"location":"parts/pins/#rpi_gpio","text":"Donkeycar installs the RPi.GPIO library on the RaspberryPi in the default installation. The Jetson.GPIO library is compatible library installed by default on the Jetson Nano. Both of these libaries work is a similar fashion to support PWM, input and output pins on the 40 pin GPIO bus of the RaspberryPi or Jetson Nano respectively. The pin specifier includes: The pin addressing scheme \"BOARD\" indicates the pin number is based on the pin numbers, 0 to 39, printed on the RaspberryPi/Jetson Nano circuit board. \"BCM\" indicates the pin number is based on the Broadcom GPIO number scheme implemented in the RaspberryPi. This scheme is emulated in the Jetson library, so \"BCM\" pin numbers can be used on the Jetson. The pin number, which depends upon the pin addressing scheme. See details of the RaspberryPi 40 pin header here: https://www.raspberrypi.com/documentation/computers/os.html#gpio-and-the-40-pin-header Jetson Nano 40 pin header uses the same board numbering scheme, although the header is physically flipped on the board, so pay attention to the numbers printed on the board. The Jetson Nano only supports 2 PWM pins and these must be enabled. See Generating PWM from the Jetson Nano For example, \"RPI_GPIO.BOARD.33\" specifies board pin 33 using the Rpi.GPIO library. For example, \"RPI_GPIO.BCM.13\" specifies Broadcom GPIO-13 using the Rpi.GPIO library. If you look at the header diagram linked above you will notice that this is the same physical pin as \"RPI_GPIO.BOARD.33\"; it is a synonymn for physical pin 33. When using the RPI_GPIO pin provider, you can choose to use the BOARD or BCM pin schemes, but all pins must use the same pin scheme. You cannot mix pin schemes.","title":"RPI_GPIO"},{"location":"parts/pins/#pigpio","text":"RaspberryPi users can optionally install the PiGPIO library and daemon to manage the pins on the 40 pin GPIO header. Note that this library does NOT work on the Jetson Nano. The library support PWM, Input and Output pins.","title":"PIGPIO"},{"location":"parts/pins/#installing-and-starting-pigpio","text":"Install the system daemon sudo apt-get update sudo apt-get install pigpio Install python support (with donkey environment activated) pip install pigpio Start the daemon sudo systemctl start pigpiod Enable the daemon on startup sudo systemctl enable pigpiod The PIGPIO pin specifier includes: - \"BCM\" PiGPIO used Broadcom (BCM) pin numbering scheme exclusively, so that is baked into the pin specifier. - The BCM pin number For example, \"PIGPIO.BCM.13\" specifies Broadcom GPIO-13. As discussed above and shown in the linked header diagram, this is exposed on board pin 33.","title":"Installing and Starting PiGPIO"},{"location":"parts/pins/#generating-pwm-from-the-jetson-nano","text":"Both the Jetson Nano and RaspberryPi4 support two hardware PWM pins. On the Jetson Nano, these must be configured.","title":"Generating PWM from the Jetson Nano"},{"location":"parts/pins/#configure-jetson-expansion-header-for-pwm","text":"ssh into the donkeycar and run this command sudo /opt/nvidia/jetson-io/jetson-io.py . It should show the Jetson Expansion Header Tool that allows you to change GPIO pin functions (see below). If your Jetson expansion header configuration does not show any PWM pins, then you will need to enable them. --- =================== Jetson Expansion Header Tool =================== | | | | | 3.3V ( 1) ( 2) 5V | | i2c2 ( 3) ( 4) 5V | | i2c2 ( 5) ( 6) GND | | unused ( 7) ( 8) uartb | | GND ( 9) (10) uartb | | unused (11) (12) unused | | unused (13) (14) GND | | unused (15) (16) unused | | 3.3V (17) (18) unused | | unused (19) (20) GND | | unused (21) (22) unused | | unused (23) (24) unused | | GND (25) (26) unused | | i2c1 (27) (28) i2c1 | | unused (29) (30) GND | | unused (31) (32) unused | | unused (33) (34) GND | | unused (35) (36) unused | | unused (37) (38) unused | | GND (39) (40) unused | | | ==================================================================== --- Choose Configure the 40 pin expansion header to activate pwm0 and pwm2: --- =================== Jetson Expansion Header Tool =================== | | | | | 3.3V ( 1) ( 2) 5V | | i2c2 ( 3) ( 4) 5V | | i2c2 ( 5) ( 6) GND | | unused ( 7) ( 8) uartb | | GND ( 9) (10) uartb | | unused (11) (12) unused | | unused (13) (14) GND | | unused (15) (16) unused | | 3.3V (17) (18) unused | | unused (19) (20) GND | | unused (21) (22) unused | | unused (23) (24) unused | | GND (25) (26) unused | | i2c1 (27) (28) i2c1 | | unused (29) (30) GND | | unused (31) (32) pwm0 | | pwm2 (33) (34) GND | | unused (35) (36) unused | | unused (37) (38) unused | | GND (39) (40) unused | | | ==================================================================== --- After enabling, pwm0 is board pin-32 and pwm2 is board pin-33.","title":"Configure Jetson Expansion Header for PWM"},{"location":"parts/rc/","text":"RC control (This only works with the RaspberryPi. The Jetson Nano does not provide the necessary GPIO pin support) You can drive Donkey with nothing more than the RC controller your car probably came with! The secret is that, thanks to the cool Pigpio library, the RaspberryPi pins can read and generate the RC signals necessary to read your RC receiver and drive your servo and motor controllers. To do this you need to either connect some jumper cables from your RC receiver to the RPi GPIO pins and then do the same for your steering servo and motor controller (it's a little fiddly but works fine) or use our forthcoming Donkeycar RC Hat, which is plug and play and includes other nice stuff like a OLED screen, a fan, encoder support and even an e-stop option (like a remote kill switch) if you happen to have a 3Ch (or more) RC transmitter. NOTE: RC control is currently only supported in the Dev branch. To use it, after you git clone donkeycar, do a git checkout dev Hardware Setup You can use the GPIO pins for RC input, output or both. In the case of RC input, the RC controller replaces a bluetooth joystick. In the case of RC output, it replaces the I2C servo driver board. The easiest way to connect RC is via the custom \"hat\" that we've designed (see above). But if you're doing it yourself, follow this wiring guide. It's a bit of a forest of jumper cables if you're doing both input and output, but remember that you only have to connect one ground and V+ cable to the RC reciever (on any channel), rather than one for every channel. Also note the the RC receiver should be connected to the 3.3v pins, while the output servo and motor controller are connected to the 5v pins. Warning: The RC receiver PWM signal is generated from the receiver input voltage, so connecting the RC receiver to 5V or even 6V from the ESC will fry the RPi! Here's what the RC receiver connection should look like Software Setup First, on the command line enter this to set the PIGPIO daemon to always run on startup: sudo systemctl enable pigpiod & sudo systemctl start pigpiod Next, in your mycar directory, edit the myconfig.py files as follows: For RC input, select pigpio_rc as your controller type in your myconfig.py file. Uncomment the line (remove the leading # ) and edit it as follows: CONTROLLER_TYPE = 'pigpio_rc' Also set use joystick to True USE_JOYSTICK_AS_DEFAULT = True For RC output, select PWM_STEERING_THROTTLE as your drive train type in your myconfig.py file. Uncomment the line (remove the leading # ) and edit it as follows: DRIVE_TRAIN_TYPE = \"PWM_STEERING_THROTTLE\" For both of these, there are additional settings you can change, such as reversing the direction of output or the pins connected: Input options: #PIGPIO RC control STEERING_RC_GPIO = 26 THROTTLE_RC_GPIO = 20 DATA_WIPER_RC_GPIO = 19 PIGPIO_STEERING_MID = 1500 # Adjust this value if your car cannot run in a straight line PIGPIO_MAX_FORWARD = 2000 # Max throttle to go fowrward. The bigger the faster PIGPIO_STOPPED_PWM = 1500 PIGPIO_MAX_REVERSE = 1000 # Max throttle to go reverse. The smaller the faster PIGPIO_SHOW_STEERING_VALUE = False PIGPIO_INVERT = False PIGPIO_JITTER = 0.025 # threshold below which no signal is reported If you are using the RC hat then the PWM output pins shown below (and defaulted in myconfig.py) must be used. If you are not using the RC hat then you are free to choose different PWM output pins. NOTE: you must install pigpio to use this configuration. See PIGPIO Output options: PWM_STEERING_PIN = \"PIGPIO.BCM.13\" # PWM output pin for steering servo PWM_THROTTLE_PIN = \"PIGPIO.BCM.18\" # PWM output pin for ESC STEERING_LEFT_PWM = int(4096 * 1 / 20) # pwm value for full left steering (1ms pulse) STEERING_RIGHT_PWM = int(4096 * 2 / 20) # pwm value for full right steering (2ms pulse) THROTTLE_FORWARD_PWM = int(4096 * 2 / 20) # pwm value for max forward (2ms pulse) THROTTLE_STOPPED_PWM = int(4096 * 1.5 / 20) # pwm value for no movement (1.5ms pulse) THROTTLE_REVERSE_PWM = int(4096 * 1 / 20) # pwm value for max reverse throttle (1ms pulse) Troubleshooting If one channel is reversed (steering left goes right, etc), either reverse that channel on your RC transmitter (that's usually a switch or setting) or change it in the output options shown above by channging the PWM_INVERTED value for that channel to True .","title":"RC control"},{"location":"parts/rc/#rc-control","text":"(This only works with the RaspberryPi. The Jetson Nano does not provide the necessary GPIO pin support) You can drive Donkey with nothing more than the RC controller your car probably came with! The secret is that, thanks to the cool Pigpio library, the RaspberryPi pins can read and generate the RC signals necessary to read your RC receiver and drive your servo and motor controllers. To do this you need to either connect some jumper cables from your RC receiver to the RPi GPIO pins and then do the same for your steering servo and motor controller (it's a little fiddly but works fine) or use our forthcoming Donkeycar RC Hat, which is plug and play and includes other nice stuff like a OLED screen, a fan, encoder support and even an e-stop option (like a remote kill switch) if you happen to have a 3Ch (or more) RC transmitter. NOTE: RC control is currently only supported in the Dev branch. To use it, after you git clone donkeycar, do a git checkout dev","title":"RC control"},{"location":"parts/rc/#hardware-setup","text":"You can use the GPIO pins for RC input, output or both. In the case of RC input, the RC controller replaces a bluetooth joystick. In the case of RC output, it replaces the I2C servo driver board. The easiest way to connect RC is via the custom \"hat\" that we've designed (see above). But if you're doing it yourself, follow this wiring guide. It's a bit of a forest of jumper cables if you're doing both input and output, but remember that you only have to connect one ground and V+ cable to the RC reciever (on any channel), rather than one for every channel. Also note the the RC receiver should be connected to the 3.3v pins, while the output servo and motor controller are connected to the 5v pins. Warning: The RC receiver PWM signal is generated from the receiver input voltage, so connecting the RC receiver to 5V or even 6V from the ESC will fry the RPi! Here's what the RC receiver connection should look like","title":"Hardware Setup"},{"location":"parts/rc/#software-setup","text":"First, on the command line enter this to set the PIGPIO daemon to always run on startup: sudo systemctl enable pigpiod & sudo systemctl start pigpiod Next, in your mycar directory, edit the myconfig.py files as follows: For RC input, select pigpio_rc as your controller type in your myconfig.py file. Uncomment the line (remove the leading # ) and edit it as follows: CONTROLLER_TYPE = 'pigpio_rc' Also set use joystick to True USE_JOYSTICK_AS_DEFAULT = True For RC output, select PWM_STEERING_THROTTLE as your drive train type in your myconfig.py file. Uncomment the line (remove the leading # ) and edit it as follows: DRIVE_TRAIN_TYPE = \"PWM_STEERING_THROTTLE\" For both of these, there are additional settings you can change, such as reversing the direction of output or the pins connected: Input options: #PIGPIO RC control STEERING_RC_GPIO = 26 THROTTLE_RC_GPIO = 20 DATA_WIPER_RC_GPIO = 19 PIGPIO_STEERING_MID = 1500 # Adjust this value if your car cannot run in a straight line PIGPIO_MAX_FORWARD = 2000 # Max throttle to go fowrward. The bigger the faster PIGPIO_STOPPED_PWM = 1500 PIGPIO_MAX_REVERSE = 1000 # Max throttle to go reverse. The smaller the faster PIGPIO_SHOW_STEERING_VALUE = False PIGPIO_INVERT = False PIGPIO_JITTER = 0.025 # threshold below which no signal is reported If you are using the RC hat then the PWM output pins shown below (and defaulted in myconfig.py) must be used. If you are not using the RC hat then you are free to choose different PWM output pins. NOTE: you must install pigpio to use this configuration. See PIGPIO Output options: PWM_STEERING_PIN = \"PIGPIO.BCM.13\" # PWM output pin for steering servo PWM_THROTTLE_PIN = \"PIGPIO.BCM.18\" # PWM output pin for ESC STEERING_LEFT_PWM = int(4096 * 1 / 20) # pwm value for full left steering (1ms pulse) STEERING_RIGHT_PWM = int(4096 * 2 / 20) # pwm value for full right steering (2ms pulse) THROTTLE_FORWARD_PWM = int(4096 * 2 / 20) # pwm value for max forward (2ms pulse) THROTTLE_STOPPED_PWM = int(4096 * 1.5 / 20) # pwm value for no movement (1.5ms pulse) THROTTLE_REVERSE_PWM = int(4096 * 1 / 20) # pwm value for max reverse throttle (1ms pulse)","title":"Software Setup"},{"location":"parts/rc/#troubleshooting","text":"If one channel is reversed (steering left goes right, etc), either reverse that channel on your RC transmitter (that's usually a switch or setting) or change it in the output options shown above by channging the PWM_INVERTED value for that channel to True .","title":"Troubleshooting"},{"location":"parts/rc_hat/","text":"Donkeycar RC Hat If you started with a ready-to-run RC car, it probably came with a RC controller. Good news: you can use it with Donkeycar, using the RC controller for manual driving. You can also plug in the car's servo and motor controller directly into the RaspberryPi without the need for a special motor/servo controller board. To do so, you can either wire up it up manually as shown in this tutorial (which works, but has a lot of fiddly wires that can fall off) or do it far more neatly with the Donkeycar RC hat, shown above, which handles all the wiring for you, along with including an OLED screen and a fan. The Donkeycar RC hat can be purchased from the Donkeycar Store . Note that it only works with the RaspberryPi, not the Jetson Nano, due to limitations with the way the Jetson handles its I/O pins. To use the hat, just use the included 3-wire cables to connect your RC receiver to the RC 1 and RC 2 pins (corresponding to the RC receiver's Channel 1 and Channel 2). Then plug your car's servo into the Servo pins and the Motor Controller into the Motor pins. In all cases, make sure you plug them in the right way, noting the +,- and S (Signal) markings. Typically the black wire is \"-\", the red wire in the middle is \"+\" and the white wire is \"S\". If you're using a standard wheel encoder , you can plug it into the \"Encoder\" pins. You can also power the RaspberryPi from this board if you have a 5V source with the \"Optional 5v power in\" pins Once you've plugged in all the cables, you can move to the software setup Software Setup First, on the command line enter this to set the PIGPIO daemon to always run on startup: sudo systemctl enable pigpiod & sudo systemctl start pigpiod Next, in your mycar directory, edit the myconfig.py files as follows: For RC input, select pigpio_rc as your controller type in your myconfig.py file. Uncomment the line (remove the leading # ) and edit it as follows: CONTROLLER_TYPE = 'pigpio_rc' Also set use joystick to True USE_JOYSTICK_AS_DEFAULT = True For RC output, select PWM_STEERING_THROTTLE as your drive train type in your myconfig.py file. Uncomment the line (remove the leading # ) and edit it as follows: DRIVE_TRAIN_TYPE = \"PWM_STEERING_THROTTLE\" For both of these, there are additional settings you can change, such as reversing the direction of output or the pins connected: Input options: #PIGPIO RC control STEERING_RC_GPIO = 26 THROTTLE_RC_GPIO = 20 DATA_WIPER_RC_GPIO = 19 PIGPIO_STEERING_MID = 1500 # Adjust this value if your car cannot run in a straight line PIGPIO_MAX_FORWARD = 2000 # Max throttle to go fowrward. The bigger the faster PIGPIO_STOPPED_PWM = 1500 PIGPIO_MAX_REVERSE = 1000 # Max throttle to go reverse. The smaller the faster PIGPIO_SHOW_STEERING_VALUE = False PIGPIO_INVERT = False PIGPIO_JITTER = 0.025 # threshold below which no signal is reported If you are using the RC hat then the PWM output pins shown below (and defaulted in myconfig.py) must be used. If you are not using the RC hat then you are free to choose different PWM output pins. NOTE: you must install pigpio to use this configuration. See PIGPIO Output options: PWM_STEERING_PIN = \"PIGPIO.BCM.13\" # PWM output pin for steering servo PWM_THROTTLE_PIN = \"PIGPIO.BCM.18\" # PWM output pin for ESC STEERING_LEFT_PWM = int(4096 * 1 / 20) # pwm value for full left steering (1ms pulse) STEERING_RIGHT_PWM = int(4096 * 2 / 20) # pwm value for full right steering (2ms pulse) THROTTLE_FORWARD_PWM = int(4096 * 2 / 20) # pwm value for max forward (2ms pulse) THROTTLE_STOPPED_PWM = int(4096 * 1.5 / 20) # pwm value for no movement (1.5ms pulse) THROTTLE_REVERSE_PWM = int(4096 * 1 / 20) # pwm value for max reverse throttle (1ms pulse) Troubleshooting If one channel is reversed (steering left goes right, etc), either reverse that channel on your RC transmitter (that's usually a switch or setting) or change it in the output options shown above by channging the PWM_INVERTED value for that channel to True . OLED setup Enable the display in myconfig.py . # SSD1306_128_32 USE_SSD1306_128_32 = True # Enable the SSD_1306 OLED Display SSD1306_128_32_I2C_BUSNUM = 1 # I2C bus number SSD1306_RESOLUTION = 1 # 1 = 128x32; 2 = 128x64 Showing your IP address on startup. One of the cool things about having an OLED screen is that you can show your car's IP address on startup, so you can connect to it. Instructions to set that up are here Troubleshooting If you are unable to start the car, ensure that the Adafruit_SSD1306 package is installed in your virtual environment. This should automatically be installed, if you are using a recent version of donkeycar . pip install Adafruit_SSD1306","title":"Rc hat"},{"location":"parts/rc_hat/#donkeycar-rc-hat","text":"If you started with a ready-to-run RC car, it probably came with a RC controller. Good news: you can use it with Donkeycar, using the RC controller for manual driving. You can also plug in the car's servo and motor controller directly into the RaspberryPi without the need for a special motor/servo controller board. To do so, you can either wire up it up manually as shown in this tutorial (which works, but has a lot of fiddly wires that can fall off) or do it far more neatly with the Donkeycar RC hat, shown above, which handles all the wiring for you, along with including an OLED screen and a fan. The Donkeycar RC hat can be purchased from the Donkeycar Store . Note that it only works with the RaspberryPi, not the Jetson Nano, due to limitations with the way the Jetson handles its I/O pins. To use the hat, just use the included 3-wire cables to connect your RC receiver to the RC 1 and RC 2 pins (corresponding to the RC receiver's Channel 1 and Channel 2). Then plug your car's servo into the Servo pins and the Motor Controller into the Motor pins. In all cases, make sure you plug them in the right way, noting the +,- and S (Signal) markings. Typically the black wire is \"-\", the red wire in the middle is \"+\" and the white wire is \"S\". If you're using a standard wheel encoder , you can plug it into the \"Encoder\" pins. You can also power the RaspberryPi from this board if you have a 5V source with the \"Optional 5v power in\" pins Once you've plugged in all the cables, you can move to the software setup","title":"Donkeycar RC Hat"},{"location":"parts/rc_hat/#software-setup","text":"First, on the command line enter this to set the PIGPIO daemon to always run on startup: sudo systemctl enable pigpiod & sudo systemctl start pigpiod Next, in your mycar directory, edit the myconfig.py files as follows: For RC input, select pigpio_rc as your controller type in your myconfig.py file. Uncomment the line (remove the leading # ) and edit it as follows: CONTROLLER_TYPE = 'pigpio_rc' Also set use joystick to True USE_JOYSTICK_AS_DEFAULT = True For RC output, select PWM_STEERING_THROTTLE as your drive train type in your myconfig.py file. Uncomment the line (remove the leading # ) and edit it as follows: DRIVE_TRAIN_TYPE = \"PWM_STEERING_THROTTLE\" For both of these, there are additional settings you can change, such as reversing the direction of output or the pins connected: Input options: #PIGPIO RC control STEERING_RC_GPIO = 26 THROTTLE_RC_GPIO = 20 DATA_WIPER_RC_GPIO = 19 PIGPIO_STEERING_MID = 1500 # Adjust this value if your car cannot run in a straight line PIGPIO_MAX_FORWARD = 2000 # Max throttle to go fowrward. The bigger the faster PIGPIO_STOPPED_PWM = 1500 PIGPIO_MAX_REVERSE = 1000 # Max throttle to go reverse. The smaller the faster PIGPIO_SHOW_STEERING_VALUE = False PIGPIO_INVERT = False PIGPIO_JITTER = 0.025 # threshold below which no signal is reported If you are using the RC hat then the PWM output pins shown below (and defaulted in myconfig.py) must be used. If you are not using the RC hat then you are free to choose different PWM output pins. NOTE: you must install pigpio to use this configuration. See PIGPIO Output options: PWM_STEERING_PIN = \"PIGPIO.BCM.13\" # PWM output pin for steering servo PWM_THROTTLE_PIN = \"PIGPIO.BCM.18\" # PWM output pin for ESC STEERING_LEFT_PWM = int(4096 * 1 / 20) # pwm value for full left steering (1ms pulse) STEERING_RIGHT_PWM = int(4096 * 2 / 20) # pwm value for full right steering (2ms pulse) THROTTLE_FORWARD_PWM = int(4096 * 2 / 20) # pwm value for max forward (2ms pulse) THROTTLE_STOPPED_PWM = int(4096 * 1.5 / 20) # pwm value for no movement (1.5ms pulse) THROTTLE_REVERSE_PWM = int(4096 * 1 / 20) # pwm value for max reverse throttle (1ms pulse)","title":"Software Setup"},{"location":"parts/rc_hat/#troubleshooting","text":"If one channel is reversed (steering left goes right, etc), either reverse that channel on your RC transmitter (that's usually a switch or setting) or change it in the output options shown above by channging the PWM_INVERTED value for that channel to True .","title":"Troubleshooting"},{"location":"parts/rc_hat/#oled-setup","text":"Enable the display in myconfig.py . # SSD1306_128_32 USE_SSD1306_128_32 = True # Enable the SSD_1306 OLED Display SSD1306_128_32_I2C_BUSNUM = 1 # I2C bus number SSD1306_RESOLUTION = 1 # 1 = 128x32; 2 = 128x64","title":"OLED setup"},{"location":"parts/rc_hat/#showing-your-ip-address-on-startup","text":"One of the cool things about having an OLED screen is that you can show your car's IP address on startup, so you can connect to it. Instructions to set that up are here","title":"Showing your IP address on startup."},{"location":"parts/rc_hat/#troubleshooting_1","text":"If you are unable to start the car, ensure that the Adafruit_SSD1306 package is installed in your virtual environment. This should automatically be installed, if you are using a recent version of donkeycar . pip install Adafruit_SSD1306","title":"Troubleshooting"},{"location":"parts/stop_sign_detection/","text":"Stop Sign Detection This part utilize a Google Coral accelerator and a pre-trained object detection model by Coral project to perform stop sign detection. If the donkey car see a stop sign, it will override the pilot/throttle to 0. In addition, a bounding box will be annotated to the cam/image_array . Your browser does not support the video tag. Requirement To use this part, you must have: Google Coral USB Accelerator How to use Put the following lines in myconfig.py STOP_SIGN_DETECTOR = True STOP_SIGN_MIN_SCORE = 0.2 STOP_SIGN_SHOW_BOUNDING_BOX = True Install Edge TPU dependencies Follow this instruction to install and setup Google Coral on Pi 4 In addition, install the dependency on your dev pc or pi4 like this pip3 install https://dl.google.com/coral/edgetpu_api/edgetpu-2.14.0-py3-none-any.whl Detecting other objects Since the pre-trained model are trained on coco, there are 80 objects that the model is able to detect. You can simply change the STOP_SIGN_CLASS_ID in stop_sign_detector.py to try. Accuracy Since SSD is not good at detecting small objects , the accuracy of detecting the stop sign from far away may not be good. There are some ways that we can make enhancement but this is out of the scope of this part.","title":"Stop Sign Detection"},{"location":"parts/stop_sign_detection/#stop-sign-detection","text":"This part utilize a Google Coral accelerator and a pre-trained object detection model by Coral project to perform stop sign detection. If the donkey car see a stop sign, it will override the pilot/throttle to 0. In addition, a bounding box will be annotated to the cam/image_array . Your browser does not support the video tag.","title":"Stop Sign Detection"},{"location":"parts/stop_sign_detection/#requirement","text":"To use this part, you must have: Google Coral USB Accelerator","title":"Requirement"},{"location":"parts/stop_sign_detection/#how-to-use","text":"Put the following lines in myconfig.py STOP_SIGN_DETECTOR = True STOP_SIGN_MIN_SCORE = 0.2 STOP_SIGN_SHOW_BOUNDING_BOX = True","title":"How to use"},{"location":"parts/stop_sign_detection/#install-edge-tpu-dependencies","text":"Follow this instruction to install and setup Google Coral on Pi 4 In addition, install the dependency on your dev pc or pi4 like this pip3 install https://dl.google.com/coral/edgetpu_api/edgetpu-2.14.0-py3-none-any.whl","title":"Install Edge TPU dependencies"},{"location":"parts/stop_sign_detection/#detecting-other-objects","text":"Since the pre-trained model are trained on coco, there are 80 objects that the model is able to detect. You can simply change the STOP_SIGN_CLASS_ID in stop_sign_detector.py to try.","title":"Detecting other objects"},{"location":"parts/stop_sign_detection/#accuracy","text":"Since SSD is not good at detecting small objects , the accuracy of detecting the stop sign from far away may not be good. There are some ways that we can make enhancement but this is out of the scope of this part.","title":"Accuracy"},{"location":"parts/stores/","text":"Tub This is the standard donkey data store and it is modeled after the ROSBAG . All sensor data is stored in a Tub . Accepted Types The following datatypes are supported. str int float / np.float image_array s and array s ( np.ndarray ) image (jpeg / png) The Tub is an append only format, that is optimized for reads (to speed up training models). It maintains indexes for records, and uses memory mapped files. The Tub exposes an Iterator that can be used to read records. These iterators can be further used by Pipeline s to do arbitrary transformations of data prior to training (for data augumentation). Example from donkeycar.parts.tub_v2 import Tub # Here we define records that have a single `input` of type `int`. inputs = ['input'] types = ['int'] tub = Tub(path, inputs, types)","title":"Stores"},{"location":"parts/stores/#tub","text":"This is the standard donkey data store and it is modeled after the ROSBAG . All sensor data is stored in a Tub .","title":"Tub"},{"location":"parts/stores/#accepted-types","text":"The following datatypes are supported. str int float / np.float image_array s and array s ( np.ndarray ) image (jpeg / png) The Tub is an append only format, that is optimized for reads (to speed up training models). It maintains indexes for records, and uses memory mapped files. The Tub exposes an Iterator that can be used to read records. These iterators can be further used by Pipeline s to do arbitrary transformations of data prior to training (for data augumentation).","title":"Accepted Types"},{"location":"parts/stores/#example","text":"from donkeycar.parts.tub_v2 import Tub # Here we define records that have a single `input` of type `int`. inputs = ['input'] types = ['int'] tub = Tub(path, inputs, types)","title":"Example"},{"location":"parts/voice_control/","text":"Alexa Support Overview This part works together with a public Alexa skill that we have released. When you say a command, the Alexa skill will forward this command to a server hosted by us to temporarily store it. Your donkey car, installed with this part and with proper configuration, poll our server for any new command from Alexa. Demo Click the image below to open the video on youtube Command Supported Report device code autopilot slowdown speedup stop/manual Get Started Use your Alexa app , navigate to Skills and Games Search for \"Donkey Car Control\" Enable the Skill Say \"Open car control and report device code\". Use a pencil to write down the device code. Follow the instructions below to install the part in donkey car software running on Pi Installation To install this part, add the following lines to manage.py , right after the controller setup. In manage.py: if cfg.USE_ALEXA_CONTROL: from donkeycar.parts.voice_control.alexa import AlexaController V.add(AlexaController(ctr, cfg), threaded=True) In myconfig.py, add the following parameters: USE_ALEXA_CONTROL = True ALEXA_DEVICE_CODE = \"123456\" Commands Autopilot Phrases: autopilot, start autopilot If you use this command, it is expected that the donkey car is started with a model. This command will set the variable mode of the controller to local . Slowdown / Speedup Phrases: slow down, speed up, go faster, go slower This command alters the cfg.AI_THROTTLE_MULT variable passed from the constructor. Each time this command is received, the AI_THROTTLE_MULT is increased/decreased by 0.05. Note: Since this command alters AI_THROTTLE_MULT , it won't speed up when you are running in user or local_angle mode. Stop/Manual Phrases: human control, user mode, stop autopilot, manual This command will set the variable mode of the controller to user Report device code Phrases: report device code, what is your device code, device code Device code is a 6-digit numeric string derived by a hash function from your Alexa device ID. In order to distinguish commands from multiple Alexa devices, commands sent to our server would require an identifier, which is the device code. When donkey car poll for new command, the part will use this device code to poll for new commands. Backend Check here for our web service source code, it is open source too. https://github.com/robocarstore/donkeycar-alexa-backend Copyright Copyright (c) 2020 Robocar Ltd","title":"Alexa Support"},{"location":"parts/voice_control/#alexa-support","text":"","title":"Alexa Support"},{"location":"parts/voice_control/#overview","text":"This part works together with a public Alexa skill that we have released. When you say a command, the Alexa skill will forward this command to a server hosted by us to temporarily store it. Your donkey car, installed with this part and with proper configuration, poll our server for any new command from Alexa.","title":"Overview"},{"location":"parts/voice_control/#demo","text":"Click the image below to open the video on youtube","title":"Demo"},{"location":"parts/voice_control/#command-supported","text":"Report device code autopilot slowdown speedup stop/manual","title":"Command Supported"},{"location":"parts/voice_control/#get-started","text":"Use your Alexa app , navigate to Skills and Games Search for \"Donkey Car Control\" Enable the Skill Say \"Open car control and report device code\". Use a pencil to write down the device code. Follow the instructions below to install the part in donkey car software running on Pi","title":"Get Started"},{"location":"parts/voice_control/#installation","text":"To install this part, add the following lines to manage.py , right after the controller setup. In manage.py: if cfg.USE_ALEXA_CONTROL: from donkeycar.parts.voice_control.alexa import AlexaController V.add(AlexaController(ctr, cfg), threaded=True) In myconfig.py, add the following parameters: USE_ALEXA_CONTROL = True ALEXA_DEVICE_CODE = \"123456\"","title":"Installation"},{"location":"parts/voice_control/#commands","text":"","title":"Commands"},{"location":"parts/voice_control/#autopilot","text":"Phrases: autopilot, start autopilot If you use this command, it is expected that the donkey car is started with a model. This command will set the variable mode of the controller to local .","title":"Autopilot"},{"location":"parts/voice_control/#slowdown-speedup","text":"Phrases: slow down, speed up, go faster, go slower This command alters the cfg.AI_THROTTLE_MULT variable passed from the constructor. Each time this command is received, the AI_THROTTLE_MULT is increased/decreased by 0.05. Note: Since this command alters AI_THROTTLE_MULT , it won't speed up when you are running in user or local_angle mode.","title":"Slowdown / Speedup"},{"location":"parts/voice_control/#stopmanual","text":"Phrases: human control, user mode, stop autopilot, manual This command will set the variable mode of the controller to user","title":"Stop/Manual"},{"location":"parts/voice_control/#report-device-code","text":"Phrases: report device code, what is your device code, device code Device code is a 6-digit numeric string derived by a hash function from your Alexa device ID. In order to distinguish commands from multiple Alexa devices, commands sent to our server would require an identifier, which is the device code. When donkey car poll for new command, the part will use this device code to poll for new commands.","title":"Report device code"},{"location":"parts/voice_control/#backend","text":"Check here for our web service source code, it is open source too. https://github.com/robocarstore/donkeycar-alexa-backend","title":"Backend"},{"location":"parts/voice_control/#copyright","text":"Copyright (c) 2020 Robocar Ltd","title":"Copyright"},{"location":"software/software_arch/","text":"\u8f6f\u4ef6\u67b6\u6784 \u6838\u5fc3\u67b6\u6784\u4f53\u7cfb \u9a74\u8f66\u7684\u6574\u4f53\u67b6\u6784\u662f\u901a\u8fc7\u5728 Linux \u7cfb\u7edf(\u76ee\u524d\u662f Ubuntu 20.04 LTS\u7248\u672c)\u4e0a\u6784\u5efa,\u901a\u8fc7 Python \u73af\u5883\u53ca OpenCV, Tensorflow, Keras, OpenVINO, Arduino\u6574\u5408\u800c\u6210. \u5b66\u4e60\u8d44\u6e90 \u8d44\u6e90\u94fe\u63a5 \u64cd\u4f5c\u7cfb\u7edf OS\u7248\u672c: Ubuntu 20.04 LTS \u4e0b\u8f7d\u94fe\u63a5: Ubuntu 20.04 LTS Desktop Python\u89e3\u91ca\u5668 \u7248\u672c: python3.7 \u4e0b\u8f7d\u94fe\u63a5: python3.7 OpenCV\u89c6\u89c9\u6846\u67b6 \u7248\u672c: 4.5.5.60 (\u6839\u636e\u5b9e\u9645\u5e73\u53f0\u9009\u62e9\u5b89\u88c5\u7248\u672c) \u4e0b\u8f7d\u94fe\u63a5: OpenCV \u9a74\u8f66\u4ee3\u7801\u89e3\u6790 \u5173\u4e8e part part \u5256\u6790","title":"\u8f6f\u4ef6\u67b6\u6784"},{"location":"software/software_arch/#_1","text":"","title":"\u8f6f\u4ef6\u67b6\u6784"},{"location":"software/software_arch/#_2","text":"\u9a74\u8f66\u7684\u6574\u4f53\u67b6\u6784\u662f\u901a\u8fc7\u5728 Linux \u7cfb\u7edf(\u76ee\u524d\u662f Ubuntu 20.04 LTS\u7248\u672c)\u4e0a\u6784\u5efa,\u901a\u8fc7 Python \u73af\u5883\u53ca OpenCV, Tensorflow, Keras, OpenVINO, Arduino\u6574\u5408\u800c\u6210.","title":"\u6838\u5fc3\u67b6\u6784\u4f53\u7cfb"},{"location":"software/software_arch/#_3","text":"\u8d44\u6e90\u94fe\u63a5","title":"\u5b66\u4e60\u8d44\u6e90"},{"location":"software/software_arch/#_4","text":"OS\u7248\u672c: Ubuntu 20.04 LTS \u4e0b\u8f7d\u94fe\u63a5: Ubuntu 20.04 LTS Desktop","title":"\u64cd\u4f5c\u7cfb\u7edf"},{"location":"software/software_arch/#python","text":"\u7248\u672c: python3.7 \u4e0b\u8f7d\u94fe\u63a5: python3.7","title":"Python\u89e3\u91ca\u5668"},{"location":"software/software_arch/#opencv","text":"\u7248\u672c: 4.5.5.60 (\u6839\u636e\u5b9e\u9645\u5e73\u53f0\u9009\u62e9\u5b89\u88c5\u7248\u672c) \u4e0b\u8f7d\u94fe\u63a5: OpenCV","title":"OpenCV\u89c6\u89c9\u6846\u67b6"},{"location":"software/software_arch/#_5","text":"\u5173\u4e8e part part \u5256\u6790","title":"\u9a74\u8f66\u4ee3\u7801\u89e3\u6790"},{"location":"work/judge/","text":"\u57f9\u8bad\u89c4\u5219","title":"\u57f9\u8bad\u89c4\u5219"},{"location":"work/judge/#_1","text":"","title":"\u57f9\u8bad\u89c4\u5219"},{"location":"work/race_S2/","text":"\u7b56\u5212\u7ec6\u8282","title":"\u7b56\u5212\u7ec6\u8282"},{"location":"work/race_S2/#_1","text":"","title":"\u7b56\u5212\u7ec6\u8282"},{"location":"work/timer/","text":"\u8ba1\u65f6\u8f6f\u4ef6","title":"\u8ba1\u65f6\u8f6f\u4ef6"},{"location":"work/timer/#_1","text":"","title":"\u8ba1\u65f6\u8f6f\u4ef6"},{"location":"work/workflow/","text":"\u5de5\u4f5c\u6d41","title":"\u5de5\u4f5c\u6d41"},{"location":"work/workflow/#_1","text":"","title":"\u5de5\u4f5c\u6d41"}]}